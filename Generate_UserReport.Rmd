---
title: "Data analysis report"
author: "by Alithea Genomics"
date: "6/17/2020"
fontsize: 20pt 
output:
  rmdformats::readthedown:
    self_contained: true
    thumbnails: true
    lightbox: false
    gallery: false
    highlight: tango
    css: Generate_UserReport.css
params:
  args: inputArgs
---

```{r markdown_setup, include = FALSE}
knitr::opts_chunk$set(echo = F)
inputArgs <- c('test_input/fastQC/nxid12916/BRBseq_v3_plate_1_S25/BRBseq_v3_plate_1_S25_R1_001_fastqc/fastqc_data.txt',
               'test_input/fastQC/nxid12916/BRBseq_v3_plate_1_S25/BRBseq_v3_plate_1_S25_R1_001_fastqc/fastqc_data.txt', 
               'test_input/BRBseq_v3_plate_1_S25_R2_001.fastq.gz_trimming_report.txt',
               'test_input/BRBseq_v3_plate_1_S25_val_1_fastqc/fastqc_data.txt',
               'test_input/stats.txt', 'test_input/mapStatsTab.csv',
               'test_input/NXT0570_nxid13444_GRCz11.100_GFP_BRB_AM_50_readsCombined.csv')
names(inputArgs) <- c('fastqcR1', 'fastqcR2', 'trimInfoR2', 'fastqcTrimR2',
                      'demultStats', 'mapStats', 'countTab')
```

```{r setup_and_functions, include = FALSE}
library(data.table)
library(DT)
library(ggrepel)
library(ggplot2)
library(ggpubr)
library(ggsignif)
library(kableExtra)
library(knitr)
library(limma)
library(plotly)
library(plyr)

# ggplot2 plotting theme
alitheaGgplot2Theme <- list(
  theme_classic(base_size = 12) +
    theme(axis.line.x = element_line(colour = 'black', size = 0.5,
                                     linetype = 'solid'),
          axis.text.x = element_text(colour = 'black', size = 12),
          axis.line.y = element_line(colour = 'black', size = 0.5,
                                     linetype ='solid'),
          axis.text.y = element_text(colour = 'black', size = 12),
          strip.background = element_blank())
)

# plotly plotting theme
alitheaPlotlyAxis <- list(color = "black", 
                          showticklabels = T, ticks = "outside", 
                          showtickprefix = "all", ticklen = 6, tickwidth = 1)
alitheaPlotlyFont <- list(color = "black", family = "Helvetica", size = 12)
 

# colors
basicColor <- '#3A89C9'
colorCode <- c("mapped to mult. loci" = '#FFBABA', 
               "NOT mapped - mismatches" = '#C48484', 
               'NOT mapped - too short' = '#991D1D',
               'NOT mapped - other' = '#730202', 
               'mapped to too many loci' = 'black',
               "uniquely mapped" = "#0C8954")

#' readFastQCsection
#' Reads a part of the fastqc report TXT file and converts it to data table
#' @param filePath path to the TXT file
#' @param sectionName name of the section you want to be read, i.e. 
#'                    '>>Per base sequence quality' or '>>Adapter Content'
readFastQCsection <- function(filePath, sectionName) {
  # connection to the file
  connect <- file(filePath, open = "r")
  # read ALL lines of the file, luckily it's not many
  allLines <- readLines(connect)
  # indicates if result vector containing line corresponding to section of 
  # interest needs to be recorded into result variable
  startFilling <- F
  result <- c()
  for (oneLine in allLines){
    if (grepl(sectionName, oneLine)) {
      startFilling <- T
      next
    } 
    if (startFilling & grepl('>>END_MODULE', oneLine)) {
      startFilling <- F
    }
    if (startFilling) {
      result <- c(result, oneLine)
    }
  }
  close(connect)
  
  # split by tab
  result <- sapply(result, function(x) strsplit(x, '\t'))
  names(result) <- NULL
  # convert to data table
  result <- do.call(rbind, result)
  colnames(result) <- result[1, ]
  colnames(result)[1] <- gsub("^#", "", colnames(result)[1]) 
  result <- result[-1, ]
  result <- as.data.table(result)
  result <- as.data.table(apply(result, 2, as.numeric))

  result
}

#' plotPerBaseQuality_ggplot2
#' Plots per base quality of the read, just like seen in FASTQC report 
#' with ggplot2
#' @param dtToPlot data table to plot, result of readFastQCsection
#' @param plotTitle title of the plot
#' @return ggplot
plotPerBaseQuality_ggplot2 <- function(dtToPlot, plotTitle = '') {
  redArea <- data.frame(x1 = 0, x2 = max(dtToPlot$Base), y1 = 0, y2 = 20)
  yelArea <- data.frame(x1 = 0, x2 = max(dtToPlot$Base), y1 = 20, y2 = 28)
  greenArea <- data.frame(x1 = 0, x2 = max(dtToPlot$Base), y1 = 28, y2 = 40)
  result <- ggplot(dtToPlot, aes(x = Base, y = Median)) + 
    geom_point(shape = 95) + 
    geom_errorbar(aes(ymin = `10th Percentile`, 
                      ymax = `90th Percentile`), width=.2,
                   position=position_dodge(.9)) +
    geom_line(aes(x = Base, y = Mean), color = 'blue') + 
    geom_rect(data = redArea, inherit.aes = F, fill = "red",  alpha = 0.2,
              mapping = aes(xmin = x1, xmax = x2, ymin = y1, ymax = y2)) +
    geom_rect(data = yelArea, inherit.aes = F, fill = "yellow",  alpha = 0.2,
              mapping = aes(xmin = x1, xmax = x2, ymin = y1, ymax = y2)) +
    geom_rect(data = greenArea, inherit.aes = F, fill = "green",  alpha = 0.2,
              mapping = aes(xmin = x1, xmax = x2, ymin = y1, ymax = y2)) +
    scale_x_continuous(breaks = seq(0, max(dtToPlot$Base), 1)) + 
    scale_y_continuous(breaks = seq(0, 40, 1)) +
    xlab('Quality score') + ylab('Position in the read, bp') +
    ggtitle(plotTitle) + alitheaGgplot2Theme
  result
}

#' plotPerBaseQuality_ggplot2
#' Plots per base quality of the read, just like seen in FASTQC report 
#' with plotly
#' @param dtToPlot data table to plot, result of readFastQCsection
#' @param plotTitle title of the plot
#' @return plotly
plotPerBaseQuality_plotly <- function(dtToPlot, plotTitle = '') {
  fig <- plot_ly(data = dtToPlot) %>% 
                add_trace(x = ~Base, y = ~Median, type = "scatter", 
                          mode = "markers", 
                marker = list(symbol = 'line-ew-open', color = 'black'),
                error_y = ~list(symmetric = F, color = 'black',
                                arrayminus = Median - `10th Percentile`,
                                array = `90th Percentile` - Median)) %>% 
                add_trace(x = ~Base, y = ~Mean, type="scatter", mode = "lines",
                line = list(color = 'blue'))
  fig <- fig %>%
         layout(fig, title = plotTitle, showlegend = F, 
                font = alitheaPlotlyFont,
                xaxis = append(alitheaPlotlyAxis, 
                               list(title = 'Position in the read, bp', 
                                    tick0 = 1, dtick = 1,
                                    range = c(0, max(dtToPlot$Base)), 
                                    showgrid = F)),
                yaxis = append(alitheaPlotlyAxis, 
                               list(title = 'Sequencing quality', 
                                    tick0 = 1, dtick = 1,
                                    range = c(0, max(c(40, 
                                              dtToPlot$`90th Percentile`))),
                                    showgrid = F)),
                shapes = list(list(type = "rect", fillcolor = "red",
                                   line = list(color = "red"), opacity = 0.3,
                                   x0 = 0, x1 = max(dtToPlot$Base), xref = "x",
                                   y0 = 0, y1 = 20, yref = "y"),
                              list(type = "rect", fillcolor = "yellow", 
                                   line = list(color = "yellow"),
                                   opacity = 0.2, x0 = 0, x1 = max(dtToPlot$Base), 
                                   xref = "x", y0 = 20, y1 = 28, yref = "y"),
                              list(type = "rect", fillcolor = "green", 
                                   line = list(color = "green"),
                                   opacity = 0.2, x0 = 0, x1 = max(dtToPlot$Base),
                                   xref = "x", y0 = 28, y1 = 40, yref = "y")))
  fig
}

#' plotAdapterContent_ggplot2
#' Plots adapter content in the read, just like seen in FASTQC report with use
#' of ggplot2 
#' @param dtToPlot data table to plot, result of readFastQCsection
#' @param plotTitle title of the plot
#' @return ggplot2
plotAdapterContent_ggplot2 <- function(dtToPlot, plotTitle = '') {
  dtToPlot <- melt(copy(dtToPlot), 'Position')
  result <- ggplot(dtToPlot, aes(x = Position, y = value, color = variable)) +
    geom_line() +
    scale_color_manual(values = c('red', 'blue', 'green', 'black', 'magenta'))+
    scale_x_continuous(breaks = seq(0, max(adapters_R1$Position), 1)) + 
    scale_y_continuous(limits = c(0, 100), breaks = seq(0, 100, 10)) +
    xlab('Position in read') + ylab('% Adapter') +
    theme(legend.position = "topright") + labs(color = "Adapter") +
    ggtitle(plotTitle) + alitheaGgplot2Theme
  result
}

#' plotAdapterContent_plotly
#' Plots adapter content in the read, just like seen in FASTQC report with use
#' of plotly
#' @param dtToPlot data table to plot, result of readFastQCsection
#' @param plotTitle title of the plot
#' @return plotly
plotAdapterContent_plotly <- function(dtToPlot, plotTitle = '') {
  dtToPlot <- melt(copy(dtToPlot), 'Position')
  fig <- plot_ly(data = dtToPlot) %>% 
    add_trace(x = ~Position, y = ~value, type = "scatter", 
              color = ~variable, mode = "lines")
  fig <- fig %>%
    layout(fig, title = plotTitle, font = alitheaPlotlyFont,
           xaxis = append(alitheaPlotlyAxis,
                         list(title = 'Position in read, bp', 
                              tick0 = 1, dtick = 1,
                              range = c(0, max(dtToPlot$Position)),
                              showgrid = F)),
           yaxis = append(alitheaPlotlyAxis,
                          list(title = 'Adapter %', tick0 = 0, dtick = 10,
                               range = c(0, 100), showgrid = F)))
  fig
}

#' readInTrimmingInfo
#' Reads in and extracts needed information from trimming report produced by
#' TrimGalore
#' @param filePath path to the trimming report
#' @return data table with 2 columns
readInTrimmingInfo <- function(filePath) {
  # lines of interest
  LOI <- c('Adapter sequence', 'Total reads processed', 
           'Reads with adapters', 'Reads written',
           'Total basepairs processed', 'Quality-trimmed',
           'Total written',
           'Number of sequence pairs removed because')
  LOI <- paste(LOI, collapse = "|")

  # connection to the file
  connect <- file(filePath, open = "r")
  # read ALL lines of the file, luckily it's not many
  allLines <- readLines(connect)
  # indicates if result vector containing line corresponding to section of 
  # interest needs to be recorded into result variable
  startFilling <- F
  result <- c()
  for (oneLine in allLines){
    if (grepl(LOI, oneLine)) {
      result <- c(result, oneLine)
    }
  }
  close(connect)
  
  # convert to table
  result <- sapply(result, function(x) strsplit(x, ':'))
  names(result) <- NULL
  result <- do.call(rbind, result)
  result[, 2] <- gsub('^ +', '', result[, 2])
  result <- as.data.frame(result)
  colnames(result) <- c('Property', 'Value')
  result
}

#' readDemultiplexInfo
#' Reads information from demultiplex statistics info file
#' @param filePath path to the demultiplex statistics report
#' @return list with two elements: Overview and PercPerBarcode
readDemultiplexInfo <- function(filePath) {
  # connection to the file
  connect <- file(filePath, open = "r")
  # read ALL lines of the file, luckily it's not many
  allLines <- readLines(connect)
  # indicates if result vector containing line corresponding to section of 
  # interest needs to be recorded into result variable
  startFilling <- F
  result <- list('')
  for (oneLine in allLines){
    if (grepl('Demultiplexing Summary', oneLine)) {
      startFilling <- T
      itemToFillIn <- 1
      next
    }
    if (grepl('Demultiplexing Details', oneLine)) {
      startFilling <- T
      result[[length(result) + 1]] <- ''
      itemToFillIn <- 2
      next
    }
    if (startFilling) {
      result[[itemToFillIn]] <- c(result[[itemToFillIn]], oneLine)
      if (grepl("Determined Barcodes", oneLine)) {
        startFilling <- F
      }
    }
  }
  close(connect)
  
  # remove 1st item from every element of the list, it's empty
  result <- lapply(result, function(x) x[-1])
  # convert each element to data frame
  result <- lapply(result, 
                   function(x) sapply(x, function(y) strsplit(y, '\t')))
  for (i in 1:length(result)) {
    names(result[[i]]) <- NULL
  }
  result <- lapply(result, function(x) do.call(rbind, x))
  for (i in 1:length(result)) {
    colnames(result[[i]]) <- result[[i]][1, ]
    result[[i]] <- result[[i]][-1, ]
  }
  result <- lapply(result, function(x) as.data.frame(x, stringsAsFactors = F))
  # conver second and third columns to numbers
  for (i in 1:length(result)) {
    result[[i]][, 2] <- as.double(result[[i]][, 2])
    result[[i]][, 3] <- as.double(result[[i]][, 3])
  }
  names(result) <- c('Overview', 'PercPerBarcode')
  # add row and column position in plate
  result[[2]]$PlateRow <- gsub('[0-9]+', '', result[[2]]$Barcode)
  result[[2]]$PlateCol <- gsub('[A-Z]+', '', result[[2]]$Barcode)
  colnames(result[[2]])[2] <- 'Reads'
  
  result
}

#' plotBarChart_plotly
#' Plots bar plot of demultiplexed statistics and of exonic reads
#' @param dtToPlot data frame to plot
#' @param mode column name to plot
#' @param xAxisTitle title of X axis
#' @param plotTitle title of the plot
#' @retun plotly
plotBarChart_plotly <- function(dtToPlot, mode = 'Reads', xAxisTitle, 
                                plotTitle) {
  # data frame to dysplay ordered values
  byPerc <- data.frame(x = dtToPlot[, mode], y = dtToPlot$Barcode, 
                       stringsAsFactors = F)
  byPerc <- byPerc[order(byPerc$x), ]
  byPerc$y <- factor(byPerc$y, levels = byPerc$y)
  # data frame to dysplay values ordered by name
  byName <- data.frame(x = dtToPlot[, mode], y = dtToPlot$Barcode,
                       stringsAsFactors = F)
  byName$y <- factor(byName$y, levels = sort(byName$y, decreasing = T))
  
  # buttons
  yAxisform <- append(alitheaPlotlyAxis, list(title = 'Sample'))
  yAxisREform <- append(yAxisform,
                        list(categoryorder = "array",
                             categoryarray = levels(byName$y)))
  updatemenus <- list(
    list(active = -1, type = "buttons",
         buttons = list(
           list(label = "Sort by value", method = "update",
                args = list(list(visible = c(T, F)),
                            list(yaxis = yAxisform))),
           list(label = "Sort by name", method = "update",
                args = list(list(visible = c(F, T)),
                            list(yaxis = yAxisREform))))))
  
  fig <- plot_ly() %>% 
    add_trace(data = byPerc, x = ~x, y = ~y, type = "bar", visible = T,
              marker = list(color = basicColor)) %>%
    add_trace(data = byName, x = ~x, y = ~y, type = "bar", visible = F,
              marker = list(color = basicColor)) %>%
    layout(updatemenus = updatemenus, title = plotTitle, showlegend = F,
           font = alitheaPlotlyFont,
           yaxis = append(alitheaPlotlyAxis, list(title = 'Sample')),
           xaxis = append(alitheaPlotlyAxis,
                          list(title = xAxisTitle, tick0 = 0, showgrid = T)))
  
  fig
}

#' plotDemultiplexPlate_plotly
#' Plots plate view of demultiplexing results
#' @param dtToPlot, data table to plot, result of readDemultiplexInfo(x)[[2]]
#' @param plotTitle title of the plot
#' @retun plotly
plotDemultiplexPlate_plotly <- function(dtToPlot, plotTitle) {
  fig <- plot_ly() %>% 
    add_trace(data = dtToPlot, x = ~PlateRow, y = ~PlateCol,
              type = 'scatter', mode = 'markers', 
              text = ~paste0(Percent, '%'),
              marker = list(size = ~10 * Percent, color = basicColor,
                            opacity = 1)) %>%
    layout(title = plotTitle, showlegend = F,
           font = alitheaPlotlyFont,
           xaxis = append(alitheaPlotlyAxis,
                          list(title = '', 
                          tick0 = 0, dtick = 1, showgrid = F)),
           yaxis = append(alitheaPlotlyAxis,
                          list(title = '', tick0 = 0, dtick = 1,
                          autorange="reversed", showgrid = F)))
  fig
}

# mapping statistics
#' readMapStatTab
#' Reads and formats one mapping stats table
#' @param mappingStatsPath path to the file with mapping stats
#' @return data table
readMapStatTab <- function(mappingStatsPath) {
  # Names of the columns
  idColNames <- c('RunID', 'LibraryID', 'SampleID', 'Specie', 'Genome', 
                  'SubSample')
  #idColNames <- c('RunID', 'LibraryID', 'SampleID', 'pos', 'SampleName',
  #                'Specie', 'Genome')
  statNames <- c(idColNames, 'total reads', 'uniquely mapped', 
                 'mapped to mult. loci', 'mapped to too many loci',
                 'NOT mapped - mismatches', 'NOT mapped - too short',
                 'NOT mapped - other')
  # read-in and assign column names
  stats <- fread(mappingStatsPath, header = F, stringsAsFactors = F, fill = T)
  setnames(stats, colnames(stats), statNames)
  # for the subsample names, remove elements of the path from it, leaving just
  # samples
  stats[, SubSample := gsub('.*/', '', SubSample)]
  stats[, SubSample := gsub('[.].*', '', SubSample)]
  stats
}

#' convertMapStatsToPerc
#' Converst mapping statistics to percentage
#' @param tabMapStats table with mapping statistics
#' @return data table
convertMapStatsToPerc <- function(tabMapStats) {
  # column names used as IDs
  idCols <- c('RunID', 'LibraryID', 'SampleID', 'Specie', 'Genome', 
                  'SubSample')
  # select ID columns
  tabMapStatsPerc <- tabMapStats[, idCols, with = F]
  # select columns with raw statistics values (integer)
  rawStats <- tabMapStats[, !colnames(tabMapStats) %in% idCols, with = F]
  # convert to percentages
  percStats <- apply(rawStats, 2, function(x) 100 * x / rawStats$`total reads`)
  percStats <- as.data.table(percStats)
  percStats[, 1] <- as.double(rawStats$`total reads`)
  # merge with the input table
  tabMapStatsPerc <- cbind(tabMapStatsPerc, percStats)
  tabMapStatsPerc
}

#' sortByForBarPlot
#' Sorts data table by the column which index was given. Converts it to data
#' frame. All string columns will be converted to vectors
#' @param dataTab data table with mapping statistics
#' @param colIndexToSort integer, column index
#' @return data frame
sortByForBarPlot <- function(dataTab, colIndexToSort) {
  # make a copy so we wouldn't change original object in case it's data table
  dataTab <- copy(dataTab)
  dataFr <- as.data.frame(dataTab)
  
  # order by the column of interest
  dataFr <- dataFr[order(dataFr[, colIndexToSort]), ]
  # these are the rest of the columns
  dependentIndex <- setdiff(1:ncol(dataTab), colIndexToSort)
  for (i in dependentIndex) {
    # if coulumn is character: convert it to factor with levels corresponding
    # to sorted column
    if (class(dataFr[, i]) == 'character') {
      dataFr[, i] <- factor(dataFr[, i], levels = unique(dataFr[, i]))
    }
  }
  
  dataFr
}

#' genVisibilityVectors
#' Creates visibility vector for stacked mapping stats bar plot
#' @param numbItems int, number of traces simultaneously dysplayed in each plot
#' @param numbReps int, number of buttons
#' @return list of vectors of length numbItems, numbReps. 
#'         numbReps vectors in the list
genVisibilityVectors <- function(numbItems, numbReps) {
  # template vector, all false for now
  tmpVect <- rep(F, numbItems * numbReps)
  # sequence of where patches of T should start 
  trueStarts <- seq(1, length(tmpVect), by = numbItems)
  result <- list()
  for (i in trueStarts) {
    toAdd <- tmpVect
    toAdd[i:(i+numbItems - 1)] <- T
    result[[length(result) + 1]] <- toAdd
  }
  result
}

#' createButtons
#' Creates switch buttons to switch between different order of mapping stats
#' @param dataList list of data frame. Each should have just 2 columns
#' @param statSortedBy character name of the column by which data was sorted
#' @param visibilityList list of visibility for traces
#' @return list, representing button
createButtons <- function(dataList, statSortedBy, visibilityList) {
  changedYaxisTickLabs <- dataList[[statSortedBy]][[statSortedBy]]$SubSample
  changedYaxisTickLabs <- levels(changedYaxisTickLabs)
  changedYaxis <- list(title = 'Sample', categoryorder = "array",
                       categoryarray = changedYaxisTickLabs)
  list(label = statSortedBy, method = "update",
       args = list(list(visible = visibilityList),
                   list(yaxis = append(alitheaPlotlyAxis,
                                       changedYaxis))))
  
}

#' addAllBarChartTraces
#' Adds bar chart traces to plotly figure
#' @param figToAdd plotly figure to which append traces
#' @param dataList list of data frames
#' @param statSortedBy character name of the column by which data was sorted
#' @param plotColors named vector, colors for plot
#' @param visibility true of false
#' @return plotly figure
addAllBarChartTraces <- function(figToAdd, dataList, statSortedBy, plotColors,
                                 visibility = F) {
  figToAdd <- figToAdd %>% 
              add_trace(data = dataList[[statSortedBy]][[statSortedBy]],
                        x = ~Value, y = ~SubSample, 
                        type = 'bar', name = statSortedBy,
                        marker = list(color = plotColors[statSortedBy]),
                        visible = visibility)
  
  otherStats <- names(dataList[[statSortedBy]])
  otherStats <- otherStats[otherStats != statSortedBy]
  for (oneMapStat in otherStats) {
    figToAdd <- figToAdd %>% 
                add_trace(data = dataList[[statSortedBy]][[oneMapStat]],
                          x = ~Value, y = ~SubSample, 
                          type = 'bar', name = oneMapStat,
                          marker = list(color = plotColors[oneMapStat]),
                          visible = visibility)
  }
  figToAdd
}

#' plotMappingStats_plotly
#' Plots mapping statistics
#' @param dtToPlot, data table to plot
#' @param plotTitle title of the plot
#' @retun plotly
plotMappingStats_plotly <- function(dtToPlot, plotTitle) {
  # names of mapping characteristics
  mapChars <- c("uniquely mapped", "mapped to mult. loci",
                "mapped to too many loci", "NOT mapped - mismatches",
                "NOT mapped - too short", "NOT mapped - other")
  # indices of the characteristics in the mapping stats table
  mapCharsInd <- match(mapChars, colnames(dtToPlot))

  # for every mapping characteristics, sort the table according to it
  dtList <- lapply(mapCharsInd, function(x) sortByForBarPlot(dtToPlot, x))
  names(dtList) <- mapChars
  # split each of the sorted by a mapping characteristic table on 
  # length(mapChars) so every sub table has just 2 columns
  dtList <- lapply(dtList, 
                  function(x) lapply(mapChars,
                                      function(y) x[, c('SubSample', y)]))
  # give sub tables the same colnames, also give sub lists names by mapping
  # chracteristic which they contain
  for (i in 1:length(dtList)) {
    names(dtList[[i]]) <- mapChars
    for (j in 1:length(dtList[[i]])) {
      colnames(dtList[[i]][[j]]) <- c('SubSample', 'Value')
    }
  }

  # generate vilibility list
  visiblList <- genVisibilityVectors(length(mapChars), length(mapChars))
  names(visiblList) <- mapChars
  
  # generate list of buttons
  buttonList <- lapply(mapChars, 
                       function(x) createButtons(dtList, x, visiblList[[x]]))
  updatemenus <- list(list(active = 0, direction = "down",
                           xref = 'paper', yref = 'paper', x = 1.5, y = 0.96, 
                           buttons = buttonList))
  
  # generate button annotation
  annot <- list(list(text = "Sort by:", x = 1.1, y = 1, xref='paper', 
                   yref = 'paper', showarrow = F))


  # add first view, visible by default
  fig <- plot_ly()
  fig <- addAllBarChartTraces(fig, dtList, names(dtList)[1], colorCode, 
                              visibility = T)
  # add following views
  for (sortedBy in names(dtList)[-1]) {
    fig <- addAllBarChartTraces(fig, dtList, sortedBy, colorCode,
                                visibility = F)
  }
  # add buttons
  fig <- fig %>% layout(updatemenus = updatemenus, title = plotTitle,
                        yaxis = append(alitheaPlotlyAxis,
                                       list(title = 'Sample')), 
                        barmode = 'stack', annotations = annot, 
                        legend = list(x = 100, y = 0))
  fig
}

#' calcPCA
#' Calculates PCA loadings
#' @param countData count table
#' @param mapStats table with mapping statistics
#' @return list, where first element is PCA coordinates of sample, and second 
#'         is a vector with PCA loadings expressed as percentage
calcPCA <- function(countData, mapStats){
  # calculate PCA loadings of count matrix
  countsPCA <- prcomp(t(countData))
  # calculate how much of variation (in percentage term) every PC explains
  percPCexpl <- round(countsPCA$sdev / sum(countsPCA$sdev) * 100, 2)
  names(percPCexpl) <- paste0('PC', 1:length(percPCexpl))
  
  # add info about uniquely mapped reads
  countsPCA <- as.data.frame(countsPCA$x)
  countsPCA$SubSample <- rownames(countsPCA)
  countsPCA <- as.data.table(countsPCA)
  mapStatsReduced <- mapStatTab[, c('SubSample', 'uniquely mapped')]
  setkey(countsPCA, SubSample)
  setkey(mapStatsReduced, SubSample)
  countsPCA <- merge(countsPCA, mapStatsReduced, all.x = T)
  
  result <- list(countsPCA, percPCexpl)
  names(result) <- c('countsPCA', 'percPCexpl')
  
  result
}

#' plotPCA_plotly
#' Plots PCA with use of plotly
#' @param pcaListToPlot list, result of calcPCA
#' @param plotTitle string, title of the plot
#' @return plotly
plotPCA_plotly <- function(pcaListToPlot, plotTitle) {
  fig <- plot_ly(data = pcaListToPlot$countsPCA) %>% 
  add_trace(x = ~PC1, y = ~PC2, type = "scatter", mode = "markers", 
            size = ~`uniquely mapped`, marker = list(color = basicColor),
            text = ~ paste("# uniq. mapped ", `uniquely mapped`), 
            hoverinfo = "text") %>%
  add_text(x = ~PC1, y = ~PC2, text = ~SubSample,
           textposition = "top right") %>%
  layout(title = plotTitle, showlegend = F, font = alitheaPlotlyFont,
         xaxis = append(alitheaPlotlyAxis, 
                        list(title = paste0('PC1 (', 
                                            pcaListToPlot$percPCexpl['PC1'],
                                            '%)'))),
         yaxis = append(alitheaPlotlyAxis, 
                        list(title = paste0('PC2 (', 
                                            pcaListToPlot$percPCexpl['PC2'],
                                            '%)'))))
  fig
}
```

```{r readInput, include = FALSE}
# number of raw reads in R1 and R2
basicStats_R1 <- readFastQCsection(inputArgs['fastqcR1'], '>>Basic Statistics')
basicStats_R2 <- readFastQCsection(inputArgs['fastqcR2'], '>>Basic Statistics')
basicStats <- data.frame(R1 = c(basicStats_R1$Value[4],basicStats_R1$Value[6],
                                basicStats_R1$Value[7]),
                         R2 = c(basicStats_R2$Value[4],basicStats_R2$Value[6],
                                basicStats_R2$Value[7]))
rownames(basicStats) <- c('Number of reads', 'Read length', 'GC percentage')

# per base sequencing quality for R1
perBaseQC_R1 <- readFastQCsection(inputArgs['fastqcR1'], 
                                  '>>Per base sequence quality')
# per base sequencing quality for R2
perBaseQC_R2 <- readFastQCsection(inputArgs['fastqcR2'], 
                                  '>>Per base sequence quality')

# adapter contamination for R1
adapters_R1 <- readFastQCsection(inputArgs['fastqcR1'], '>>Adapter Content')
# adapter contamination for R2
adapters_R2 <- readFastQCsection(inputArgs['fastqcR2'], '>>Adapter Content')

# trimming report for R2 (R1 isn't trimmed)
trimInf_R2 <- as.data.table(readInTrimmingInfo(inputArgs['trimInfoR2']))
# per base sequencing quality for R2 after trimming
perBaseQCtrim_R2 <- readFastQCsection(inputArgs['fastqcTrimR2'], 
                                     '>>Per base sequence quality')
# adapter contamination for R2 after trimming
adaptersTrim_R2 <- readFastQCsection(inputArgs['fastqcTrimR2'], 
                                     '>>Adapter Content')

# statistics of demultiplexing
demultiplexStats <- readDemultiplexInfo(inputArgs['demultStats'])

# mapping statistics
mapStatTab <- readMapStatTab(inputArgs['mapStats'])

# count table 
countTab <- fread(inputArgs['countTab'])
setnames(countTab, 'Unknown_Barcode', 'undetermined')
```

```{r computeExonicReads, include = FALSE}
# calculate number of exonic reads
exonicReads <- colSums(countTab[, -c('Gene_id', 'Gene_name')])
exonicReads <- data.frame(Barcode = names(exonicReads), Reads = exonicReads)

# compute percentage of exonic reads from uniquely mapped reads
mapStatTabUniqMap <- mapStatTab[, c('SubSample', 'uniquely mapped'), 
                                with = F]
colnames(mapStatTabUniqMap)[1] <- 'Sample'
mapStatTabUniqMap <- as.data.table(mapStatTabUniqMap)
# merge with exonic reads
colnames(exonicReads)[1] <- 'Barcode'
exonicReads <- as.data.table(exonicReads)
setkey(exonicReads, 'Barcode')
colnames(mapStatTabUniqMap)[1] <- 'Barcode'
setkey(mapStatTabUniqMap, 'Barcode')
exonicReads <- merge(exonicReads, mapStatTabUniqMap)
exonicReads[, Percent := Reads / `uniquely mapped`]
exonicReads <- as.data.frame(exonicReads)
```

```{r computeNumbExprGenes, include = FALSE}
# number of genes with > 1 count
numbExprGenes1 <- apply(countTab[, -c('Gene_id', 'Gene_name')], 2, 
                         function(x) sum(x > 1))
numbExprGenes1 <- data.frame(Barcode = names(numbExprGenes1), 
                             NumbGenes = numbExprGenes1)
# number of genes with > 10 counts
numbExprGenes10 <- apply(countTab[, -c('Gene_id', 'Gene_name')], 2, 
                         function(x) sum(x > 10))
numbExprGenes10 <- data.frame(Barcode = names(numbExprGenes10), 
                              NumbGenes = numbExprGenes10)
```

```{r normCounts, include = FALSE}
# names of the QC rows in the count table
qcNames <- c("__alignment_not_unique", "__ambiguous", "__no_feature",
             "__not_aligned", "__too_low_aQual")
countTabMatr <- as.matrix(countTab[, -2:-1])
rownames(countTabMatr) <- countTab$Gene_id
# normalize with voom
countsNormVoom <- voom(counts = countTabMatr, normalize.method = "quantile")
countsNormVoom <- countsNormVoom$E
# now we can also remove QC rows from the table
countsNormVoom <- countsNormVoom[!rownames(countsNormVoom) %in% qcNames, ]
```

```{r calcPCA, include = FALSE}
countsRawPCA <- calcPCA(countTab[, -2:-1])
countsNormPCA <- calcPCA(countsNormVoom[, -2:-1])
```

# Quality control of the raw sequencing data
## General information

```{r generalInfo, results = 'asis'}
kable(basicStats, caption = 'Information about sequencing')
```

## Per-base sequence quality {.tabset}
The plot below displays quality scores across read length for read 1 (barcodes)
and read 2 (actual RNA).

Bad sequence quality
most likely caused by the sequencing machine failure
or tagmentation

###R1
```{r perBaseQC_R1, fig.height = 6, fig.width = 8.5, fig.align = "left"}
plotPerBaseQuality_plotly(perBaseQC_R1, 'Per base quality for R1')
```

###R2
```{r perBaseQC_R2, fig.height = 6, fig.width = 8.5, fig.align = "left"}
plotPerBaseQuality_plotly(perBaseQC_R2, 'Per base quality for R2')
```

## Adapter content{.tabset}

Adapter contamination

###R1
```{r adapterQC_R1, fig.height = 6, fig.width = 8.5, fig.align = "left"}
plotAdapterContent_plotly(adapters_R1, 'Adapter contamination in R1')
```

###R2
```{r adapterQC_R2, fig.height = 6, fig.width = 8.5, fig.align = "left"}
plotAdapterContent_plotly(adapters_R2, 'Adapter contamination in R2')
```


# Trimming results

>Important note: R1 is not trimmed. 

## Table
```{r trimmingTable, results = 'asis'}
trimInf_R2 <- as.data.table(readInTrimmingInfo(inputArgs['trimInfoR2']))
setnames(trimInf_R2, 'Value', 'R2')

kable(trimInf_R2, caption = 'Trimming statistics')
```

## Per-base sequence quality
After trimming

### R2
```{r perBaseTrimQC_R2, fig.height = 6, fig.width = 8.5, fig.align = "left"}
plotPerBaseQuality_plotly(perBaseQCtrim_R2, 'Per base quality for R2')
```

## Adapter content 

### R2
```{r adapterTrimQC_R2, fig.height = 6, fig.width = 8.5, fig.align = "left"}
plotAdapterContent_plotly(adaptersTrim_R2, 'Adapter contamination in R1')
```

# Demultiplexing {.tabset}

```{r demultiplexStats, results = "asis"}
kable(demultiplexStats[[1]], caption = 'Overview of demultiplexing')
```

## Bar plot
```{r demultiplexStatsPlot, fig.height = 12, fig.width = 8.5, fig.align = "left"}
plotBarChart_plotly(demultiplexStats[[2]], 'Percent', '% of reads per sample',
                    'Demultiplexing results')
```

## Plate view
```{r demultiplexPlatePlot, fig.height = 6, fig.width = 8.5, fig.align = "left"}
plotDemultiplexPlate_plotly(demultiplexStats[[2]], 
                            '% of reads per sample, plate view')
```


# Mapping {.tabset}

## Barplot - raw values
```{r mapStatsPlot, fig.height = 6, fig.width = 8.5, fig.align = "left"}
plotMappingStats_plotly(mapStatTab, 'Overview of mapping statistics')
```

## Barplot - percentages
```{r mapStatsPlotPerc, fig.height = 6, fig.width = 8.5, fig.align = "left"}
plotMappingStats_plotly(convertMapStatsToPerc(mapStatTab), 
                        'Overview of mapping statistics (in %)')
```

## Table 
```{r mapStatsTab, results = 'asis'}
kable(mapStatTab, caption = 'Mapping statistics') %>%
      kable_styling(bootstrap_options = c("striped", "hover", "condensed",
                                          "responsive")) %>%
  scroll_box(width = "100%", height = "500px")
```

# Exonic reads {.tabset}

## Number of reads
```{r exonicReads, fig.height = 6, fig.width = 8.5, fig.align = "left"}
plotBarChart_plotly(exonicReads, mode = 'Reads', 
                    'Number of exonic reads per sample',
                    'Number of exonic reads per sample')
```

## % from uniquely mapped
```{r exonicReadsPerc, fig.height = 6, fig.width = 8.5, fig.align = "left"}
plotBarChart_plotly(exonicReads, mode = 'Percent',  
                    '% of exonic reads per sample',
                    '% of exonic reads per sample')
```

## Table 
```{r exonicReadsTab, results = 'asis'}
colnames(exonicReads) <- c('Sample', 'Number of reads',
                           '% from uniquely mapped')
kable(exonicReads, caption = 'Exonic reads') %>%
      kable_styling(bootstrap_options = c("striped", "hover", "condensed",
                                          "responsive")) %>%
  scroll_box(width = "100%", height = "500px")
```

# Number of expressed genes {.tabset}

## > 1 read per gene
```{r numbExprGenes1, fig.height = 6, fig.width = 8.5, fig.align = "left"}
plotBarChart_plotly(numbExprGenes1, mode = 'NumbGenes', 
                    'Number of genes with > 1 reads', 
                    'Number of genes')
```

## > 10 reads per gene
```{r numbExprGenes10, fig.height = 6, fig.width = 8.5, fig.align = "left"}
plotBarChart_plotly(numbExprGenes10, mode = 'NumbGenes',  
                    'Number of genes with > 10 reads',
                    'Number of genes')
```

## Table
```{r NumbGenesTab, results = 'asis'}
colnames(numbExprGenes1) <- c('Sample', 'Number of genes')
kable(numbExprGenes1, caption = 'Number of genes with > 1 read') %>%
      kable_styling(bootstrap_options = c("striped", "hover", "condensed",
                                          "responsive")) %>%
  scroll_box(width = "100%", height = "500px")
```

# PCA {.tabset}

## raw counts 
```{r pcaRaw, fig.height = 6, fig.width = 8.5, fig.align = "left"}
plotPCA_plotly(countsRawPCA, 'PCA based on raw counts')
```

## normalized data
```{r PcaNorm, fig.height = 6, fig.width = 8.5, fig.align = "left"}
plotPCA_plotly(countsNormPCA, 'PCA based on normalized counts')
```
