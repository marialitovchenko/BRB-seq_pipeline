---
title: "Data analysis report"
author: "by Alithea Genomics"
date: "6/17/2020"
fontsize: 20pt 
output:
  rmdformats::readthedown:
    self_contained: true
    thumbnails: true
    lightbox: false
    gallery: false
    highlight: tango
params:
  args: inputArgs
---

```{r markdown_setup, include = FALSE}
knitr::opts_chunk$set(echo = F)
inputArgs <- c('test_input/fastQC/nxid12916/BRBseq_v3_plate_1_S25/BRBseq_v3_plate_1_S25_R1_001_fastqc/fastqc_data.txt',
               'test_input/fastQC/nxid12916/BRBseq_v3_plate_1_S25/BRBseq_v3_plate_1_S25_R1_001_fastqc/fastqc_data.txt', 
               'test_input/BRBseq_v3_plate_1_S25_R2_001.fastq.gz_trimming_report.txt',
               'test_input/BRBseq_v3_plate_1_S25_val_1_fastqc/fastqc_data.txt',
               'test_input/stats.txt', 'test_input/mapStatsTab.csv')
names(inputArgs) <- c('fastqcR1', 'fastqcR2', 'trimInfoR2', 'fastqcTrimR2',
                      'demultStats', 'mapStats')
```

```{r setup_and_functions, include = FALSE}
library(data.table)
library(DT)
library(ggrepel)
library(ggplot2)
library(ggpubr)
library(ggsignif)
library(plotly)
library(plyr)
library(prettydoc)

# ggplot2 plotting theme
alitheaGgplot2Theme <- list(
  theme_classic(base_size = 12) +
    theme(axis.line.x = element_line(colour = 'black', size = 0.5,
                                     linetype = 'solid'),
          axis.text.x = element_text(colour = 'black', size = 12),
          axis.line.y = element_line(colour = 'black', size = 0.5,
                                     linetype ='solid'),
          axis.text.y = element_text(colour = 'black', size = 12),
          strip.background = element_blank())
)

# plotly plotting theme
alitheaPlotlyAxis <- list(color = "black", 
                          showticklabels = T, ticks = "outside", 
                          showtickprefix = "all", ticklen = 6, tickwidth = 1)
alitheaPlotlyFont <- list(color = "black", family = "Helvetica", size = 12)
 

# colors
basicColor <- '#556D7D'
colorCode <- c("mapped to mult. loci" = '#FFBABA', 
               "NOT mapped - mismatches" = '#C48484', 
               'NOT mapped - too short' = '#991D1D',
               'NOT mapped - other' = '#730202', 
               'mapped to too many loci' = 'black',
               "uniquely mapped" = "#0C8954")

#' readFastQCsection
#' Reads a part of the fastqc report TXT file and converts it to data table
#' @param filePath path to the TXT file
#' @param sectionName name of the section you want to be read, i.e. 
#'                    '>>Per base sequence quality' or '>>Adapter Content'
readFastQCsection <- function(filePath, sectionName) {
  # connection to the file
  connect <- file(filePath, open = "r")
  # read ALL lines of the file, luckily it's not many
  allLines <- readLines(connect)
  # indicates if result vector containing line corresponding to section of 
  # interest needs to be recorded into result variable
  startFilling <- F
  result <- c()
  for (oneLine in allLines){
    if (grepl(sectionName, oneLine)) {
      startFilling <- T
      next
    } 
    if (startFilling & grepl('>>END_MODULE', oneLine)) {
      startFilling <- F
    }
    if (startFilling) {
      result <- c(result, oneLine)
    }
  }
  close(connect)
  
  # split by tab
  result <- sapply(result, function(x) strsplit(x, '\t'))
  names(result) <- NULL
  # convert to data table
  result <- do.call(rbind, result)
  colnames(result) <- result[1, ]
  colnames(result)[1] <- gsub("^#", "", colnames(result)[1]) 
  result <- result[-1, ]
  result <- as.data.table(result)
  result <- as.data.table(apply(result, 2, as.numeric))

  result
}

#' plotPerBaseQuality_ggplot2
#' Plots per base quality of the read, just like seen in FASTQC report 
#' with ggplot2
#' @param dtToPlot data table to plot, result of readFastQCsection
#' @param plotTitle title of the plot
#' @return ggplot
plotPerBaseQuality_ggplot2 <- function(dtToPlot, plotTitle = '') {
  redArea <- data.frame(x1 = 0, x2 = max(dtToPlot$Base), y1 = 0, y2 = 20)
  yelArea <- data.frame(x1 = 0, x2 = max(dtToPlot$Base), y1 = 20, y2 = 28)
  greenArea <- data.frame(x1 = 0, x2 = max(dtToPlot$Base), y1 = 28, y2 = 40)
  result <- ggplot(dtToPlot, aes(x = Base, y = Median)) + 
    geom_point(shape = 95) + 
    geom_errorbar(aes(ymin = `10th Percentile`, 
                      ymax = `90th Percentile`), width=.2,
                   position=position_dodge(.9)) +
    geom_line(aes(x = Base, y = Mean), color = 'blue') + 
    geom_rect(data = redArea, inherit.aes = F, fill = "red",  alpha = 0.2,
              mapping = aes(xmin = x1, xmax = x2, ymin = y1, ymax = y2)) +
    geom_rect(data = yelArea, inherit.aes = F, fill = "yellow",  alpha = 0.2,
              mapping = aes(xmin = x1, xmax = x2, ymin = y1, ymax = y2)) +
    geom_rect(data = greenArea, inherit.aes = F, fill = "green",  alpha = 0.2,
              mapping = aes(xmin = x1, xmax = x2, ymin = y1, ymax = y2)) +
    scale_x_continuous(breaks = seq(0, max(dtToPlot$Base), 1)) + 
    scale_y_continuous(breaks = seq(0, 40, 1)) +
    xlab('Quality score') + ylab('Position in the read, bp') +
    ggtitle(plotTitle) + alitheaGgplot2Theme
  result
}

#' plotPerBaseQuality_ggplot2
#' Plots per base quality of the read, just like seen in FASTQC report 
#' with plotly
#' @param dtToPlot data table to plot, result of readFastQCsection
#' @param plotTitle title of the plot
#' @return plotly
plotPerBaseQuality_plotly <- function(dtToPlot, plotTitle = '') {
  fig <- plot_ly(data = dtToPlot) %>% 
                add_trace(x = ~Base, y = ~Median, type = "scatter", 
                          mode = "markers", 
                marker = list(symbol = 'line-ew-open', color = 'black'),
                error_y = ~list(symmetric = F, color = 'black',
                                arrayminus = Median - `10th Percentile`,
                                array = `90th Percentile` - Median)) %>% 
                add_trace(x = ~Base, y = ~Mean, type="scatter", mode = "lines",
                line = list(color = 'blue'))
  fig <- fig %>%
         layout(fig, title = plotTitle, showlegend = F, 
                font = alitheaPlotlyFont,
                xaxis = append(alitheaPlotlyAxis, 
                               list(title = 'Position in the read, bp', 
                                    tick0 = 1, dtick = 1,
                                    range = c(0, max(dtToPlot$Base)), 
                                    showgrid = F)),
                yaxis = append(alitheaPlotlyAxis, 
                               list(title = 'Sequencing quality', 
                                    tick0 = 1, dtick = 1,
                                    range = c(0, max(c(40, 
                                              dtToPlot$`90th Percentile`))),
                                    showgrid = F)),
                shapes = list(list(type = "rect", fillcolor = "red",
                                   line = list(color = "red"), opacity = 0.3,
                                   x0 = 0, x1 = max(dtToPlot$Base), xref = "x",
                                   y0 = 0, y1 = 20, yref = "y"),
                              list(type = "rect", fillcolor = "yellow", 
                                   line = list(color = "yellow"),
                                   opacity = 0.2, x0 = 0, x1 = max(dtToPlot$Base), 
                                   xref = "x", y0 = 20, y1 = 28, yref = "y"),
                              list(type = "rect", fillcolor = "green", 
                                   line = list(color = "green"),
                                   opacity = 0.2, x0 = 0, x1 = max(dtToPlot$Base),
                                   xref = "x", y0 = 28, y1 = 40, yref = "y")))
  fig
}

#' plotAdapterContent_ggplot2
#' Plots adapter content in the read, just like seen in FASTQC report with use
#' of ggplot2 
#' @param dtToPlot data table to plot, result of readFastQCsection
#' @param plotTitle title of the plot
#' @return ggplot2
plotAdapterContent_ggplot2 <- function(dtToPlot, plotTitle = '') {
  dtToPlot <- melt(copy(dtToPlot), 'Position')
  result <- ggplot(dtToPlot, aes(x = Position, y = value, color = variable)) +
    geom_line() +
    scale_color_manual(values = c('red', 'blue', 'green', 'black', 'magenta'))+
    scale_x_continuous(breaks = seq(0, max(adapters_R1$Position), 1)) + 
    scale_y_continuous(limits = c(0, 100), breaks = seq(0, 100, 10)) +
    xlab('Position in read') + ylab('% Adapter') +
    theme(legend.position = "topright") + labs(color = "Adapter") +
    ggtitle(plotTitle) + alitheaGgplot2Theme
  result
}

#' plotAdapterContent_plotly
#' Plots adapter content in the read, just like seen in FASTQC report with use
#' of plotly
#' @param dtToPlot data table to plot, result of readFastQCsection
#' @param plotTitle title of the plot
#' @return plotly
plotAdapterContent_plotly <- function(dtToPlot, plotTitle = '') {
  dtToPlot <- melt(copy(dtToPlot), 'Position')
  fig <- plot_ly(data = dtToPlot) %>% 
    add_trace(x = ~Position, y = ~value, type = "scatter", 
              color = ~variable, mode = "lines")
  fig <- fig %>%
    layout(fig, title = plotTitle, font = alitheaPlotlyFont,
           xaxis = append(alitheaPlotlyAxis,
                         list(title = 'Position in read, bp', 
                              tick0 = 1, dtick = 1,
                              range = c(0, max(dtToPlot$Position)),
                              showgrid = F)),
           yaxis = append(alitheaPlotlyAxis,
                          list(title = 'Adapter %', tick0 = 0, dtick = 10,
                               range = c(0, 100), showgrid = F)))
  fig
}

#' readInTrimmingInfo
#' Reads in and extracts needed information from trimming report produced by
#' TrimGalore
#' @param filePath path to the trimming report
#' @return data table with 2 columns
readInTrimmingInfo <- function(filePath) {
  # lines of interest
  LOI <- c('Adapter sequence', 'Total reads processed', 
           'Reads with adapters', 'Reads written',
           'Total basepairs processed', 'Quality-trimmed',
           'Total written',
           'Number of sequence pairs removed because')
  LOI <- paste(LOI, collapse = "|")

  # connection to the file
  connect <- file(filePath, open = "r")
  # read ALL lines of the file, luckily it's not many
  allLines <- readLines(connect)
  # indicates if result vector containing line corresponding to section of 
  # interest needs to be recorded into result variable
  startFilling <- F
  result <- c()
  for (oneLine in allLines){
    if (grepl(LOI, oneLine)) {
      result <- c(result, oneLine)
    }
  }
  close(connect)
  
  # convert to table
  result <- sapply(result, function(x) strsplit(x, ':'))
  names(result) <- NULL
  result <- do.call(rbind, result)
  result[, 2] <- gsub('^ +', '', result[, 2])
  result <- as.data.frame(result)
  colnames(result) <- c('Property', 'Value')
  result
}

#' readDemultiplexInfo
#' Reads information from demultiplex statistics info file
#' @param filePath path to the demultiplex statistics report
#' @return list with two elements: Overview and PercPerBarcode
readDemultiplexInfo <- function(filePath) {
  # connection to the file
  connect <- file(filePath, open = "r")
  # read ALL lines of the file, luckily it's not many
  allLines <- readLines(connect)
  # indicates if result vector containing line corresponding to section of 
  # interest needs to be recorded into result variable
  startFilling <- F
  result <- list('')
  for (oneLine in allLines){
    if (grepl('Demultiplexing Summary', oneLine)) {
      startFilling <- T
      itemToFillIn <- 1
      next
    }
    if (grepl('Demultiplexing Details', oneLine)) {
      startFilling <- T
      result[[length(result) + 1]] <- ''
      itemToFillIn <- 2
      next
    }
    if (startFilling) {
      result[[itemToFillIn]] <- c(result[[itemToFillIn]], oneLine)
      if (grepl("Determined Barcodes", oneLine)) {
        startFilling <- F
      }
    }
  }
  close(connect)
  
  # remove 1st item from every element of the list, it's empty
  result <- lapply(result, function(x) x[-1])
  # convert each element to data frame
  result <- lapply(result, 
                   function(x) sapply(x, function(y) strsplit(y, '\t')))
  for (i in 1:length(result)) {
    names(result[[i]]) <- NULL
  }
  result <- lapply(result, function(x) do.call(rbind, x))
  for (i in 1:length(result)) {
    colnames(result[[i]]) <- result[[i]][1, ]
    result[[i]] <- result[[i]][-1, ]
  }
  result <- lapply(result, function(x) as.data.frame(x, stringsAsFactors = F))
  # conver second and third columns to numbers
  for (i in 1:length(result)) {
    result[[i]][, 2] <- as.double(result[[i]][, 2])
    result[[i]][, 3] <- as.double(result[[i]][, 3])
  }
  names(result) <- c('Overview', 'PercPerBarcode')
  # add row and column position in plate
  result[[2]]$PlateRow <- gsub('[0-9]+', '', result[[2]]$Barcode)
  result[[2]]$PlateCol <- gsub('[A-Z]+', '', result[[2]]$Barcode)
  
  result
}

#' plotDemultipleStats
#' Plots bar plot of demultiplexed statistics
#' @param dtToPlot, data table to plot, result of readDemultiplexInfo(x)[[2]]
#' @param plotTitle title of the plot
#' @retun plotly
plotDemultipleStats_plotly <- function(dtToPlot, plotTitle) {
  # data frame to dysplay values ordered by percentage
  byPerc <- data.frame(x = dtToPlot$Percent, y = dtToPlot$Barcode, 
                       stringsAsFactors = F)
  byPerc <- byPerc[order(byPerc$x), ]
  byPerc$y <- factor(byPerc$y, levels = byPerc$y)

  # data frame to dysplay values ordered by name
  byName <- data.frame(x = dtToPlot$Percent, 
                       y = paste(dtToPlot$PlateRow, dtToPlot$PlateCol),
                       stringsAsFactors = F)
  byName <- byName[order(byName$y, decreasing = T), ]
  byName$y <- factor(byName$y, levels = byName$y)

  # buttons
  updatemenus <- list(
  list(active = -1, type = "buttons",
       buttons = list(
         list(label = "Sort by value", method = "update",
              args = list(list(visible = c(T, F)))),
         list(label = "Sort by name",method = "update",
              args = list(list(visible = c(F, T)))))))
  
  fig <- plot_ly() %>% 
    add_trace(data = byPerc, x = ~x, y = ~y, type = "bar", visible = T,
              marker = list(color = basicColor)) %>%
    add_trace(data = byName, x = ~x, y = ~y, type = "bar", visible = F,
              marker = list(color = basicColor)) %>%
    layout(updatemenus = updatemenus, title = plotTitle, showlegend = F,
           font = alitheaPlotlyFont,
           xaxis = append(alitheaPlotlyAxis,
                          list(title = '% of reads going to this sample',
                               tick0 = 0, dtick = 1)),
           yaxis = append(alitheaPlotlyAxis,
                          list(title = 'Sample', tick0 = 0, dtick = 1)))
  
  fig
}
```

```{r readInput, include = FALSE}
# number of raw reads in R1 and R2
basicStats_R1 <- readFastQCsection(inputArgs['fastqcR1'], '>>Basic Statistics')
basicStats_R2 <- readFastQCsection(inputArgs['fastqcR2'], '>>Basic Statistics')
basicStats <- data.frame(R1 = c(basicStats_R1$Value[4],basicStats_R1$Value[6],
                                basicStats_R1$Value[7]),
                         R2 = c(basicStats_R2$Value[4],basicStats_R2$Value[6],
                                basicStats_R2$Value[7]))
rownames(basicStats) <- c('Number of reads', 'Read length', 'GC percentage')

# per base sequencing quality for R1
perBaseQC_R1 <- readFastQCsection(inputArgs['fastqcR1'], 
                                  '>>Per base sequence quality')
# per base sequencing quality for R2
perBaseQC_R2 <- readFastQCsection(inputArgs['fastqcR2'], 
                                  '>>Per base sequence quality')

# adapter contamination for R1
adapters_R1 <- readFastQCsection(inputArgs['fastqcR1'], '>>Adapter Content')
# adapter contamination for R2
adapters_R2 <- readFastQCsection(inputArgs['fastqcR2'], '>>Adapter Content')

# trimming report for R2 (R1 isn't trimmed)
trimInf_R2 <- as.data.table(readInTrimmingInfo(inputArgs['trimInfoR2']))
# per base sequencing quality for R2 after trimming
perBaseQCtrim_R2 <- readFastQCsection(inputArgs['fastqcTrimR2'], 
                                     '>>Per base sequence quality')
# adapter contamination for R2 after trimming
adaptersTrim_R2 <- readFastQCsection(inputArgs['fastqcTrimR2'], 
                                     '>>Adapter Content')

# statistics of demultiplexing
demultiplexStats <- readDemultiplexInfo(inputArgs['demultStats'])
```

# Quality control of the raw sequencing data
## General information

```{r generalInfo, results = 'asis'}
library(knitr)
kable(basicStats, caption = 'Information about sequencing')
```

## Per-base sequence quality {.tabset}
The plot below displays quality scores across read length for read 1 (barcodes)
and read 2 (actual RNA).

Bad sequence quality
most likely caused by the sequencing machine failure
or tagmentation

###R1
```{r perBaseQC_R1, fig.height = 6, fig.width = 8, fig.align = "left"}
plotPerBaseQuality_plotly(perBaseQC_R1, 'Per base quality for R1')
```

###R2
```{r perBaseQC_R2, fig.height = 6, fig.width = 8, fig.align = "left"}
plotPerBaseQuality_plotly(perBaseQC_R2, 'Per base quality for R2')
```

## Adapter content{.tabset}

Adapter contamination

###R1
```{r adapterQC_R1, fig.height = 6, fig.width = 8, fig.align = "left"}
plotAdapterContent_plotly(adapters_R1, 'Adapter contamination in R1')
```

###R2
```{r adapterQC_R2, fig.height = 6, fig.width = 8, fig.align = "left"}
plotAdapterContent_plotly(adapters_R2, 'Adapter contamination in R2')
```


# Trimming results

>Important note: R1 is not trimmed. 

## Table
```{r trimmingTable, results = 'asis'}
trimInf_R2 <- as.data.table(readInTrimmingInfo(inputArgs['trimInfoR2']))
setnames(trimInf_R2, 'Value', 'R2')

library(knitr)
kable(trimInf_R2, caption = 'Trimming statistics')
```

## Per-base sequence quality
After trimming

### R2
```{r perBaseTrimQC_R2, fig.height = 6, fig.width = 8, fig.align = "left"}
plotPerBaseQuality_plotly(perBaseQCtrim_R2, 'Per base quality for R2')
```

## Adapter content 

### R2
```{r adapterTrimQC_R2, fig.height = 6, fig.width = 8, fig.align = "left"}
plotAdapterContent_plotly(adaptersTrim_R2, 'Adapter contamination in R1')
```

# Demultiplexing

```{r demultiplexStats, results = "asis"}
library(knitr)
kable(demultiplexStats[[1]], caption = 'Overview of demultiplexing')
```


```{r demultiplexStatsPlot, fig.height = 12, fig.width = 10, fig.align = "left"}
plotDemultipleStats_plotly(demultiplexStats[[2]], '% of reads per sample')
```