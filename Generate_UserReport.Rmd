---
title: "Data analysis report"
author: "by Alithea Genomics"
date: "6/17/2020"
fontsize: 20pt 
output:
  rmdformats::readthedown:
    self_contained: true
    thumbnails: true
    lightbox: false
    gallery: false
    highlight: tango
    css: Generate_UserReport.css
params:
  args: inputArgs
---

<style>
.column-left{
  float: left;
  width: 50%;
  text-align: left;
}
.column-right{
  float: right;
  width: 50%;
  text-align: left;
}
</style>

```{r markdown_setup, include = FALSE}
knitr::opts_chunk$set(echo = F)
inputArgs <- c('Test User', 'Test PI', 'NXT0570', 'nxid13448', 'BRB_AM_100',
               'danio_rerio', 'GRCz11.100_GFP', 'test_input/fastQC/nxid12916/BRBseq_v3_plate_1_S25/BRBseq_v3_plate_1_S25_R1_001_fastqc/fastqc_data.txt',
               'test_input/fastQC/nxid12916/BRBseq_v3_plate_1_S25/BRBseq_v3_plate_1_S25_R1_001_fastqc/fastqc_data.txt', 
               'test_input/BRBseq_v3_plate_1_S25_R2_001.fastq.gz_trimming_report.txt',
               'test_input/BRBseq_v3_plate_1_S25_val_1_fastqc/fastqc_data.txt',
               'test_input/stats.txt', 'test_input/mapStatsTab.csv',
               'test_input/NXT0570_nxid13444_GRCz11.100_GFP_BRB_AM_50_readsCombined.csv')
names(inputArgs) <- c('User', 'PI', 'RunID', 'LibraryID', 'SampleID', 'Specie',
                      'Genome', 'fastqcR1', 'fastqcR2', 'trimInfoR2', 'fastqcTrimR2',
                      'demultStats', 'mapStats', 'countTab')
```

```{r setup_and_functions, include = FALSE}
library(data.table)
library(DT)
library(ggrepel)
library(ggplot2)
library(ggpubr)
library(ggsignif)
library(kableExtra)
library(knitr)
library(limma)
library(plotly)
library(plyr)

# ggplot2 plotting theme
alitheaGgplot2Theme <- list(
  theme_classic(base_size = 12) +
    theme(axis.line.x = element_line(colour = 'black', size = 0.5,
                                     linetype = 'solid'),
          axis.text.x = element_text(colour = 'black', size = 12),
          axis.line.y = element_line(colour = 'black', size = 0.5,
                                     linetype ='solid'),
          axis.text.y = element_text(colour = 'black', size = 12),
          strip.background = element_blank())
)

# plotly plotting theme
alitheaPlotlyAxis <- list(color = "black", 
                          showticklabels = T, ticks = "outside", 
                          showtickprefix = "all", ticklen = 6, tickwidth = 1)
alitheaPlotlyFont <- list(color = "black", family = "Helvetica", size = 12)
 

# colors
basicColor <- '#3A89C9'
colorCode <- c("mapped to mult. loci" = '#FFBABA', 
               "NOT mapped - mismatches" = '#C48484', 
               'NOT mapped - too short' = '#991D1D',
               'NOT mapped - other' = '#730202', 
               'mapped to too many loci' = 'black',
               "uniquely mapped" = "#0C8954")

#' readFastQCsection
#' Reads a part of the fastqc report TXT file and converts it to data table
#' @param filePath path to the TXT file
#' @param sectionName name of the section you want to be read, i.e. 
#'                    '>>Per base sequence quality' or '>>Adapter Content'
readFastQCsection <- function(filePath, sectionName) {
  # connection to the file
  connect <- file(filePath, open = "r")
  # read ALL lines of the file, luckily it's not many
  allLines <- readLines(connect)
  # indicates if result vector containing line corresponding to section of 
  # interest needs to be recorded into result variable
  startFilling <- F
  result <- c()
  for (oneLine in allLines){
    if (grepl(sectionName, oneLine)) {
      startFilling <- T
      next
    } 
    if (startFilling & grepl('>>END_MODULE', oneLine)) {
      startFilling <- F
    }
    if (startFilling) {
      result <- c(result, oneLine)
    }
  }
  close(connect)
  
  # split by tab
  result <- sapply(result, function(x) strsplit(x, '\t'))
  names(result) <- NULL
  # convert to data table
  result <- do.call(rbind, result)
  colnames(result) <- result[1, ]
  colnames(result)[1] <- gsub("^#", "", colnames(result)[1]) 
  result <- result[-1, ]
  result <- as.data.table(result)
  result <- as.data.table(apply(result, 2, as.numeric))

  result
}

#' plotPerBaseQuality_ggplot2
#' Plots per base quality of the read, just like seen in FASTQC report 
#' with ggplot2
#' @param dtToPlot data table to plot, result of readFastQCsection
#' @param plotTitle title of the plot
#' @return ggplot
plotPerBaseQuality_ggplot2 <- function(dtToPlot, plotTitle = '') {
  redArea <- data.frame(x1 = 0, x2 = max(dtToPlot$Base), y1 = 0, y2 = 20)
  yelArea <- data.frame(x1 = 0, x2 = max(dtToPlot$Base), y1 = 20, y2 = 28)
  greenArea <- data.frame(x1 = 0, x2 = max(dtToPlot$Base), y1 = 28, y2 = 40)
  result <- ggplot(dtToPlot, aes(x = Base, y = Median)) + 
    geom_point(shape = 95) + 
    geom_errorbar(aes(ymin = `10th Percentile`, 
                      ymax = `90th Percentile`), width=.2,
                   position=position_dodge(.9)) +
    geom_line(aes(x = Base, y = Mean), color = 'blue') + 
    geom_rect(data = redArea, inherit.aes = F, fill = "red",  alpha = 0.2,
              mapping = aes(xmin = x1, xmax = x2, ymin = y1, ymax = y2)) +
    geom_rect(data = yelArea, inherit.aes = F, fill = "yellow",  alpha = 0.2,
              mapping = aes(xmin = x1, xmax = x2, ymin = y1, ymax = y2)) +
    geom_rect(data = greenArea, inherit.aes = F, fill = "green",  alpha = 0.2,
              mapping = aes(xmin = x1, xmax = x2, ymin = y1, ymax = y2)) +
    scale_x_continuous(breaks = seq(0, max(dtToPlot$Base), 1)) + 
    scale_y_continuous(breaks = seq(0, 40, 1)) +
    xlab('Quality score') + ylab('Position in the read, bp') +
    ggtitle(plotTitle) + alitheaGgplot2Theme
  result
}

#' plotPerBaseQuality_ggplot2
#' Plots per base quality of the read, just like seen in FASTQC report 
#' with plotly
#' @param dtToPlot data table to plot, result of readFastQCsection
#' @param plotTitle title of the plot
#' @return plotly
plotPerBaseQuality_plotly <- function(dtToPlot, plotTitle = '') {
  fig <- plot_ly(data = dtToPlot) %>% 
                add_trace(x = ~Base, y = ~Median, type = "scatter", 
                          mode = "markers", 
                marker = list(symbol = 'line-ew-open', color = 'black'),
                error_y = ~list(symmetric = F, color = 'black',
                                arrayminus = Median - `10th Percentile`,
                                array = `90th Percentile` - Median),
                text = ~ paste0("Base: ", Base, "\nMedian quality: ", Median), 
                hoverinfo = "text") %>% 
                add_trace(x = ~Base, y = ~Mean, type="scatter", mode = "lines",
                line = list(color = 'blue'),
                text = ~ paste0("Base: ", Base, "\nMean quality: ", 
                                round(Mean, 2)), 
                hoverinfo = "text")
  fig <- fig %>%
         layout(fig, title = plotTitle, showlegend = F, 
                font = alitheaPlotlyFont,
                xaxis = append(alitheaPlotlyAxis, 
                               list(title = 'Position in the read, bp', 
                                    tick0 = 1, dtick = 1,
                                    range = c(0, max(dtToPlot$Base)), 
                                    showgrid = F)),
                yaxis = append(alitheaPlotlyAxis, 
                               list(title = 'Sequencing quality', 
                                    tick0 = 1, dtick = 1,
                                    range = c(0, max(c(40, 
                                              dtToPlot$`90th Percentile`))),
                                    showgrid = F)),
                shapes = list(list(type = "rect", fillcolor = "red",
                                   line = list(color = "red"), opacity = 0.3,
                                   x0 = 0, x1 = max(dtToPlot$Base), xref = "x",
                                   y0 = 0, y1 = 20, yref = "y"),
                              list(type = "rect", fillcolor = "yellow", 
                                   line = list(color = "yellow"),
                                   opacity = 0.2, x0 = 0, x1 = max(dtToPlot$Base), 
                                   xref = "x", y0 = 20, y1 = 28, yref = "y"),
                              list(type = "rect", fillcolor = "green", 
                                   line = list(color = "green"),
                                   opacity = 0.2, x0 = 0, x1 = max(dtToPlot$Base),
                                   xref = "x", y0 = 28, y1 = 40, yref = "y")))
  fig
}

#' plotAdapterContent_ggplot2
#' Plots adapter content in the read, just like seen in FASTQC report with use
#' of ggplot2 
#' @param dtToPlot data table to plot, result of readFastQCsection
#' @param plotTitle title of the plot
#' @return ggplot2
plotAdapterContent_ggplot2 <- function(dtToPlot, plotTitle = '') {
  dtToPlot <- melt(copy(dtToPlot), 'Position')
  result <- ggplot(dtToPlot, aes(x = Position, y = value, color = variable)) +
    geom_line() +
    scale_color_manual(values = c('red', 'blue', 'green', 'black', 'magenta'))+
    scale_x_continuous(breaks = seq(0, max(adapters_R1$Position), 1)) + 
    scale_y_continuous(limits = c(0, 100), breaks = seq(0, 100, 10)) +
    xlab('Position in read') + ylab('% Adapter') +
    theme(legend.position = "topright") + labs(color = "Adapter") +
    ggtitle(plotTitle) + alitheaGgplot2Theme
  result
}

#' plotAdapterContent_plotly
#' Plots adapter content in the read, just like seen in FASTQC report with use
#' of plotly
#' @param dtToPlot data table to plot, result of readFastQCsection
#' @param plotTitle title of the plot
#' @return plotly
plotAdapterContent_plotly <- function(dtToPlot, plotTitle = '') {
  dtToPlot <- melt(copy(dtToPlot), 'Position')
  fig <- plot_ly(data = dtToPlot) %>% 
    add_trace(x = ~Position, y = ~value, type = "scatter", 
              color = ~variable, mode = "lines",
              text = ~ paste0("Adapter: ", variable, "\nBase: ", Position, 
                              "\n%: ", round(value, 2)),
              hoverinfo = "text")
  fig <- fig %>%
    layout(fig, title = plotTitle, font = alitheaPlotlyFont,
           xaxis = append(alitheaPlotlyAxis,
                         list(title = 'Position in read, bp', 
                              tick0 = 1, dtick = 1,
                              range = c(0, max(dtToPlot$Position)),
                              showgrid = F)),
           yaxis = append(alitheaPlotlyAxis,
                          list(title = 'Adapter %', tick0 = 0, dtick = 10,
                               range = c(0, 100), showgrid = F)))
  fig
}

#' readInTrimmingInfo
#' Reads in and extracts needed information from trimming report produced by
#' TrimGalore
#' @param filePath path to the trimming report
#' @return data table with 2 columns
readInTrimmingInfo <- function(filePath) {
  # lines of interest
  LOI <- c('Adapter sequence', 'Total reads processed', 
           'Reads with adapters', 'Reads written',
           'Total basepairs processed', 'Quality-trimmed',
           'Total written',
           'Number of sequence pairs removed because')
  LOI <- paste(LOI, collapse = "|")

  # connection to the file
  connect <- file(filePath, open = "r")
  # read ALL lines of the file, luckily it's not many
  allLines <- readLines(connect)
  # indicates if result vector containing line corresponding to section of 
  # interest needs to be recorded into result variable
  startFilling <- F
  result <- c()
  for (oneLine in allLines){
    if (grepl(LOI, oneLine)) {
      result <- c(result, oneLine)
    }
  }
  close(connect)
  
  # convert to table
  result <- sapply(result, function(x) strsplit(x, ':'))
  names(result) <- NULL
  result <- do.call(rbind, result)
  result[, 2] <- gsub('^ +', '', result[, 2])
  result <- as.data.frame(result)
  colnames(result) <- c('Property', 'Value')
  result
}

#' readDemultiplexInfo
#' Reads information from demultiplex statistics info file
#' @param filePath path to the demultiplex statistics report
#' @return list with two elements: Overview and PercPerBarcode
readDemultiplexInfo <- function(filePath) {
  # connection to the file
  connect <- file(filePath, open = "r")
  # read ALL lines of the file, luckily it's not many
  allLines <- readLines(connect)
  # indicates if result vector containing line corresponding to section of 
  # interest needs to be recorded into result variable
  startFilling <- F
  result <- list('')
  for (oneLine in allLines){
    if (grepl('Demultiplexing Summary', oneLine)) {
      startFilling <- T
      itemToFillIn <- 1
      next
    }
    if (grepl('Demultiplexing Details', oneLine)) {
      startFilling <- T
      result[[length(result) + 1]] <- ''
      itemToFillIn <- 2
      next
    }
    if (startFilling) {
      result[[itemToFillIn]] <- c(result[[itemToFillIn]], oneLine)
      if (grepl("Determined Barcodes", oneLine)) {
        startFilling <- F
      }
    }
  }
  close(connect)
  
  # remove 1st item from every element of the list, it's empty
  result <- lapply(result, function(x) x[-1])
  # convert each element to data frame
  result <- lapply(result, 
                   function(x) sapply(x, function(y) strsplit(y, '\t')))
  for (i in 1:length(result)) {
    names(result[[i]]) <- NULL
  }
  result <- lapply(result, function(x) do.call(rbind, x))
  for (i in 1:length(result)) {
    colnames(result[[i]]) <- result[[i]][1, ]
    result[[i]] <- result[[i]][-1, ]
  }
  result <- lapply(result, function(x) as.data.frame(x, stringsAsFactors = F))
  # conver second and third columns to numbers
  for (i in 1:length(result)) {
    result[[i]][, 2] <- as.double(result[[i]][, 2])
    result[[i]][, 3] <- as.double(result[[i]][, 3])
  }
  names(result) <- c('Overview', 'PercPerBarcode')
  # add row and column position in plate
  result[[2]]$PlateRow <- gsub('[0-9]+', '', result[[2]]$Barcode)
  result[[2]]$PlateCol <- gsub('[A-Z]+', '', result[[2]]$Barcode)
  colnames(result[[2]])[2] <- 'Reads'
  
  result
}

#' plotBarChart_plotly
#' Plots bar plot of demultiplexed statistics and of exonic reads
#' @param dtToPlot data frame to plot
#' @param mode column name to plot
#' @param xAxisTitle title of X axis
#' @param plotTitle title of the plot
#' @retun plotly
plotBarChart_plotly <- function(dtToPlot, mode = 'Reads', xAxisTitle, 
                                plotTitle) {
  # data frame to dysplay ordered values
  byPerc <- data.frame(x = dtToPlot[, mode], y = dtToPlot$Barcode, 
                       stringsAsFactors = F)
  byPerc <- byPerc[order(byPerc$x), ]
  byPerc$y <- factor(byPerc$y, levels = byPerc$y)
  # data frame to dysplay values ordered by name
  byName <- data.frame(x = dtToPlot[, mode], y = dtToPlot$Barcode,
                       stringsAsFactors = F)
  byName$y <- factor(byName$y, levels = sort(byName$y, decreasing = T))
  
  # buttons
  yAxisform <- append(alitheaPlotlyAxis, list(title = 'Sample', dtick = 1))
  yAxisREform <- append(yAxisform,
                        list(categoryorder = "array",
                             categoryarray = levels(byName$y)))
  updatemenus <- list(
    list(active = -1, type = "buttons",
         buttons = list(
           list(label = "Sort by value", method = "update",
                args = list(list(visible = c(T, F)),
                            list(yaxis = yAxisform))),
           list(label = "Sort by name", method = "update",
                args = list(list(visible = c(F, T)),
                            list(yaxis = yAxisREform))))))
  
  fig <- plot_ly() %>% 
    add_trace(data = byPerc, x = ~x, y = ~y, type = "bar", visible = T,
              marker = list(color = basicColor),
              text = ~ paste0("Sample: ", y, "\nValue: ", round(x, 2)),
              hoverinfo = "text") %>%
    add_trace(data = byName, x = ~x, y = ~y, type = "bar", visible = F,
              marker = list(color = basicColor),
              text = ~ paste0("Sample: ", y, "\nValue: ", round(x, 2)),
              hoverinfo = "text") %>%
    layout(updatemenus = updatemenus, title = plotTitle, showlegend = F,
           font = alitheaPlotlyFont,
           yaxis = append(alitheaPlotlyAxis, 
                          list(title = 'Sample', dtick = 1)),
           xaxis = append(alitheaPlotlyAxis,
                          list(title = xAxisTitle, tick0 = 0, showgrid = T)))
  
  fig
}

#' plotDemultiplexPlate_plotly
#' Plots plate view of demultiplexing results
#' @param dtToPlot, data table to plot, result of readDemultiplexInfo(x)[[2]]
#' @param plotTitle title of the plot
#' @retun plotly
plotDemultiplexPlate_plotly <- function(dtToPlot, plotTitle) {
  fig <- plot_ly() %>% 
    add_trace(data = dtToPlot, x = ~PlateRow, y = ~PlateCol,
              type = 'scatter', mode = 'markers', 
              text = ~paste0(Percent, '%'),
              marker = list(size = ~10 * Percent, color = basicColor,
                            opacity = 1),
              text = ~ paste0("Sample: ", Barcode, "\nValue: ",
                              round(Percent, 2)),
              hoverinfo = "text") %>%
    layout(title = plotTitle, showlegend = F,
           font = alitheaPlotlyFont,
           xaxis = append(alitheaPlotlyAxis,
                          list(title = '', 
                          tick0 = 0, dtick = 1, showgrid = F)),
           yaxis = append(alitheaPlotlyAxis,
                          list(title = '', tick0 = 0, dtick = 1,
                          autorange="reversed", showgrid = F)))
  fig
}

# mapping statistics
#' readMapStatTab
#' Reads and formats one mapping stats table
#' @param mappingStatsPath path to the file with mapping stats
#' @return data table
readMapStatTab <- function(mappingStatsPath) {
  # Names of the columns
  idColNames <- c('RunID', 'LibraryID', 'SampleID', 'Specie', 'Genome', 
                  'SubSample')
  #idColNames <- c('RunID', 'LibraryID', 'SampleID', 'pos', 'SampleName',
  #                'Specie', 'Genome')
  statNames <- c(idColNames, 'total reads', 'uniquely mapped', 
                 'mapped to mult. loci', 'mapped to too many loci',
                 'NOT mapped - mismatches', 'NOT mapped - too short',
                 'NOT mapped - other')
  # read-in and assign column names
  stats <- fread(mappingStatsPath, header = F, stringsAsFactors = F, fill = T)
  setnames(stats, colnames(stats), statNames)
  # for the subsample names, remove elements of the path from it, leaving just
  # samples
  stats[, SubSample := gsub('.*/', '', SubSample)]
  stats[, SubSample := gsub('[.].*', '', SubSample)]
  stats
}

#' convertMapStatsToPerc
#' Converst mapping statistics to percentage
#' @param tabMapStats table with mapping statistics
#' @return data table
convertMapStatsToPerc <- function(tabMapStats) {
  # column names used as IDs
  idCols <- c('RunID', 'LibraryID', 'SampleID', 'Specie', 'Genome', 
                  'SubSample')
  # select ID columns
  tabMapStatsPerc <- tabMapStats[, idCols, with = F]
  # select columns with raw statistics values (integer)
  rawStats <- tabMapStats[, !colnames(tabMapStats) %in% idCols, with = F]
  # convert to percentages
  percStats <- apply(rawStats, 2, function(x) 100 * x / rawStats$`total reads`)
  percStats <- as.data.table(percStats)
  percStats[, 1] <- as.double(rawStats$`total reads`)
  # merge with the input table
  tabMapStatsPerc <- cbind(tabMapStatsPerc, percStats)
  tabMapStatsPerc
}

#' sortByForBarPlot
#' Sorts data table by the column which index was given. Converts it to data
#' frame. All string columns will be converted to vectors
#' @param dataTab data table with mapping statistics
#' @param colIndexToSort integer, column index
#' @return data frame
sortByForBarPlot <- function(dataTab, colIndexToSort) {
  # make a copy so we wouldn't change original object in case it's data table
  dataTab <- copy(dataTab)
  dataFr <- as.data.frame(dataTab)
  
  # order by the column of interest
  dataFr <- dataFr[order(dataFr[, colIndexToSort]), ]
  # these are the rest of the columns
  dependentIndex <- setdiff(1:ncol(dataTab), colIndexToSort)
  for (i in dependentIndex) {
    # if coulumn is character: convert it to factor with levels corresponding
    # to sorted column
    if (class(dataFr[, i]) == 'character') {
      dataFr[, i] <- factor(dataFr[, i], levels = unique(dataFr[, i]))
    }
  }
  
  dataFr
}

#' genVisibilityVectors
#' Creates visibility vector for stacked mapping stats bar plot
#' @param numbItems int, number of traces simultaneously dysplayed in each plot
#' @param numbReps int, number of buttons
#' @return list of vectors of length numbItems, numbReps. 
#'         numbReps vectors in the list
genVisibilityVectors <- function(numbItems, numbReps) {
  # template vector, all false for now
  tmpVect <- rep(F, numbItems * numbReps)
  # sequence of where patches of T should start 
  trueStarts <- seq(1, length(tmpVect), by = numbItems)
  result <- list()
  for (i in trueStarts) {
    toAdd <- tmpVect
    toAdd[i:(i+numbItems - 1)] <- T
    result[[length(result) + 1]] <- toAdd
  }
  result
}

#' createButtons
#' Creates switch buttons to switch between different order of mapping stats
#' @param dataList list of data frame. Each should have just 2 columns
#' @param statSortedBy character name of the column by which data was sorted
#' @param visibilityList list of visibility for traces
#' @return list, representing button
createButtons <- function(dataList, statSortedBy, visibilityList) {
  changedYaxisTickLabs <- dataList[[statSortedBy]][[statSortedBy]]$SubSample
  changedYaxisTickLabs <- levels(changedYaxisTickLabs)
  changedYaxis <- list(title = 'Sample', categoryorder = "array",
                       categoryarray = changedYaxisTickLabs, dtick = 1)
  list(label = statSortedBy, method = "update",
       args = list(list(visible = visibilityList),
                   list(yaxis = append(alitheaPlotlyAxis,
                                       changedYaxis))))
  
}

#' addAllBarChartTraces
#' Adds bar chart traces to plotly figure
#' @param figToAdd plotly figure to which append traces
#' @param dataList list of data frames
#' @param statSortedBy character name of the column by which data was sorted
#' @param plotColors named vector, colors for plot
#' @param visibility true of false
#' @return plotly figure
addAllBarChartTraces <- function(figToAdd, dataList, statSortedBy, plotColors,
                                 visibility = F) {
  figToAdd <- figToAdd %>% 
              add_trace(data = dataList[[statSortedBy]][[statSortedBy]],
                        x = ~Value, y = ~SubSample, 
                        type = 'bar', name = statSortedBy,
                        marker = list(color = plotColors[statSortedBy]),
                        visible = visibility,
                        text = ~ paste0(statSortedBy, " in ", SubSample,
                                        "\n", round(Value, 2)),
                        hoverinfo = "text")
  
  otherStats <- names(dataList[[statSortedBy]])
  otherStats <- otherStats[otherStats != statSortedBy]
  for (oneMapStat in otherStats) {
    figToAdd <- figToAdd %>% 
                add_trace(data = dataList[[statSortedBy]][[oneMapStat]],
                          x = ~Value, y = ~SubSample, 
                          type = 'bar', name = oneMapStat,
                          marker = list(color = plotColors[oneMapStat]),
                          visible = visibility,
                          text = ~ paste0(oneMapStat, " in ", SubSample,
                                        "\n", round(Value, 2)),
                          hoverinfo = "text")
  }
  figToAdd
}

#' plotMappingStats_plotly
#' Plots mapping statistics
#' @param dtToPlot, data table to plot
#' @param plotTitle title of the plot
#' @retun plotly
plotMappingStats_plotly <- function(dtToPlot, plotTitle) {
  # names of mapping characteristics
  mapChars <- c("uniquely mapped", "mapped to mult. loci",
                "mapped to too many loci", "NOT mapped - mismatches",
                "NOT mapped - too short", "NOT mapped - other")
  # indices of the characteristics in the mapping stats table
  mapCharsInd <- match(mapChars, colnames(dtToPlot))

  # for every mapping characteristics, sort the table according to it
  dtList <- lapply(mapCharsInd, function(x) sortByForBarPlot(dtToPlot, x))
  names(dtList) <- mapChars
  # split each of the sorted by a mapping characteristic table on 
  # length(mapChars) so every sub table has just 2 columns
  dtList <- lapply(dtList, 
                  function(x) lapply(mapChars,
                                      function(y) x[, c('SubSample', y)]))
  # give sub tables the same colnames, also give sub lists names by mapping
  # chracteristic which they contain
  for (i in 1:length(dtList)) {
    names(dtList[[i]]) <- mapChars
    for (j in 1:length(dtList[[i]])) {
      colnames(dtList[[i]][[j]]) <- c('SubSample', 'Value')
    }
  }

  # generate vilibility list
  visiblList <- genVisibilityVectors(length(mapChars), length(mapChars))
  names(visiblList) <- mapChars
  
  # generate list of buttons
  buttonList <- lapply(mapChars, 
                       function(x) createButtons(dtList, x, visiblList[[x]]))
  updatemenus <- list(list(active = 0, direction = "down",
                           xref = 'paper', yref = 'paper', x = 1.5, y = 0.96, 
                           buttons = buttonList))
  
  # generate button annotation
  annot <- list(list(text = "Sort by:", x = 1.1, y = 1, xref='paper', 
                   yref = 'paper', showarrow = F))


  # add first view, visible by default
  fig <- plot_ly()
  fig <- addAllBarChartTraces(fig, dtList, names(dtList)[1], colorCode, 
                              visibility = T)
  # add following views
  for (sortedBy in names(dtList)[-1]) {
    fig <- addAllBarChartTraces(fig, dtList, sortedBy, colorCode,
                                visibility = F)
  }
  # add buttons
  fig <- fig %>% layout(updatemenus = updatemenus, title = plotTitle,
                        yaxis = append(alitheaPlotlyAxis, 
                                       list(title = 'Sample', dtick = 1)), 
                        barmode = 'stack', annotations = annot, 
                        legend = list(x = 100, y = 0))
  fig
}

#' calcPCA
#' Calculates PCA loadings
#' @param countData count table
#' @param mapStats table with mapping statistics
#' @return list, where first element is PCA coordinates of sample, and second 
#'         is a vector with PCA loadings expressed as percentage
calcPCA <- function(countData, mapStats){
  # calculate PCA loadings of count matrix
  countsPCA <- prcomp(t(countData))
  # calculate how much of variation (in percentage term) every PC explains
  percPCexpl <- round(countsPCA$sdev / sum(countsPCA$sdev) * 100, 2)
  names(percPCexpl) <- paste0('PC', 1:length(percPCexpl))
  
  # add info about uniquely mapped reads
  countsPCA <- as.data.frame(countsPCA$x)
  countsPCA$SubSample <- rownames(countsPCA)
  countsPCA <- as.data.table(countsPCA)
  mapStatsReduced <- mapStatTab[, c('SubSample', 'uniquely mapped')]
  setkey(countsPCA, SubSample)
  setkey(mapStatsReduced, SubSample)
  countsPCA <- merge(countsPCA, mapStatsReduced, all.x = T)
  
  result <- list(countsPCA, percPCexpl)
  names(result) <- c('countsPCA', 'percPCexpl')
  
  result
}

#' plotPCA_plotly
#' Plots PCA with use of plotly
#' @param pcaListToPlot list, result of calcPCA
#' @param plotTitle string, title of the plot
#' @return plotly
plotPCA_plotly <- function(pcaListToPlot, plotTitle) {
  fig <- plot_ly(data = pcaListToPlot$countsPCA) %>% 
  add_trace(x = ~PC1, y = ~PC2, type = "scatter", mode = "markers", 
            size = ~`uniquely mapped`, marker = list(color = basicColor),
            text = ~ paste("# uniq. mapped ", `uniquely mapped`), 
            hoverinfo = "text") %>%
  add_text(x = ~PC1, y = ~PC2, text = ~SubSample,
           textposition = "top right") %>%
  layout(title = plotTitle, showlegend = F, font = alitheaPlotlyFont,
         xaxis = append(alitheaPlotlyAxis, 
                        list(title = paste0('PC1 (', 
                                            pcaListToPlot$percPCexpl['PC1'],
                                            '%)'))),
         yaxis = append(alitheaPlotlyAxis, 
                        list(title = paste0('PC2 (', 
                                            pcaListToPlot$percPCexpl['PC2'],
                                            '%)'))))
  fig
}
```

```{r readInput, include = FALSE}
# number of raw reads in R1 and R2
basicStats_R1 <- readFastQCsection(inputArgs['fastqcR1'], '>>Basic Statistics')
basicStats_R2 <- readFastQCsection(inputArgs['fastqcR2'], '>>Basic Statistics')
basicStats <- data.frame(R1 = c(basicStats_R1$Value[4],basicStats_R1$Value[6],
                                basicStats_R1$Value[7]),
                         R2 = c(basicStats_R2$Value[4],basicStats_R2$Value[6],
                                basicStats_R2$Value[7]))
rownames(basicStats) <- c('Number of reads', 'Read length', 'GC percentage')

# per base sequencing quality for R1
perBaseQC_R1 <- readFastQCsection(inputArgs['fastqcR1'], 
                                  '>>Per base sequence quality')
# per base sequencing quality for R2
perBaseQC_R2 <- readFastQCsection(inputArgs['fastqcR2'], 
                                  '>>Per base sequence quality')

# adapter contamination for R1
adapters_R1 <- readFastQCsection(inputArgs['fastqcR1'], '>>Adapter Content')
# adapter contamination for R2
adapters_R2 <- readFastQCsection(inputArgs['fastqcR2'], '>>Adapter Content')

# trimming report for R2 (R1 isn't trimmed)
trimInf_R2 <- as.data.table(readInTrimmingInfo(inputArgs['trimInfoR2']))
# per base sequencing quality for R2 after trimming
perBaseQCtrim_R2 <- readFastQCsection(inputArgs['fastqcTrimR2'], 
                                     '>>Per base sequence quality')
# adapter contamination for R2 after trimming
adaptersTrim_R2 <- readFastQCsection(inputArgs['fastqcTrimR2'], 
                                     '>>Adapter Content')

# statistics of demultiplexing
demultiplexStats <- readDemultiplexInfo(inputArgs['demultStats'])

# mapping statistics
mapStatTab <- readMapStatTab(inputArgs['mapStats'])

# count table 
countTab <- fread(inputArgs['countTab'])
setnames(countTab, 'Unknown_Barcode', 'undetermined')
```

```{r computeExonicReads, include = FALSE}
# calculate number of exonic reads
exonicReads <- colSums(countTab[, -c('Gene_id', 'Gene_name')])
exonicReads <- data.frame(Barcode = names(exonicReads), Reads = exonicReads)

# compute percentage of exonic reads from uniquely mapped reads
mapStatTabUniqMap <- mapStatTab[, c('SubSample', 'uniquely mapped'), 
                                with = F]
colnames(mapStatTabUniqMap)[1] <- 'Sample'
mapStatTabUniqMap <- as.data.table(mapStatTabUniqMap)
# merge with exonic reads
colnames(exonicReads)[1] <- 'Barcode'
exonicReads <- as.data.table(exonicReads)
setkey(exonicReads, 'Barcode')
colnames(mapStatTabUniqMap)[1] <- 'Barcode'
setkey(mapStatTabUniqMap, 'Barcode')
exonicReads <- merge(exonicReads, mapStatTabUniqMap)
exonicReads[, Percent := Reads / `uniquely mapped`]
exonicReads <- as.data.frame(exonicReads)
```

```{r computeNumbExprGenes, include = FALSE}
# number of genes with > 1 count
numbExprGenes1 <- apply(countTab[, -c('Gene_id', 'Gene_name')], 2, 
                         function(x) sum(x > 1))
numbExprGenes1 <- data.frame(Barcode = names(numbExprGenes1), 
                             NumbGenes = numbExprGenes1)
# number of genes with > 10 counts
numbExprGenes10 <- apply(countTab[, -c('Gene_id', 'Gene_name')], 2, 
                         function(x) sum(x > 10))
numbExprGenes10 <- data.frame(Barcode = names(numbExprGenes10), 
                              NumbGenes = numbExprGenes10)
```

```{r normCounts, include = FALSE}
# names of the QC rows in the count table
qcNames <- c("__alignment_not_unique", "__ambiguous", "__no_feature",
             "__not_aligned", "__too_low_aQual")
countTabMatr <- as.matrix(countTab[, -2:-1])
rownames(countTabMatr) <- countTab$Gene_id
# normalize with voom
countsNormVoom <- voom(counts = countTabMatr, normalize.method = "quantile")
countsNormVoom <- countsNormVoom$E
# now we can also remove QC rows from the table
countsNormVoom <- countsNormVoom[!rownames(countsNormVoom) %in% qcNames, ]
```

```{r calcPCA, include = FALSE}
countsRawPCA <- calcPCA(countTab[, -2:-1])
countsNormPCA <- calcPCA(countsNormVoom[, -2:-1])
```

```{r calcPlotHeigth, include = FALSE}
sampleNumb <- length(unique(demultiplexStats[[2]]$Barcode))
mapStatsHeigth <- max(4.5, 0.116 * sampleNumb + 0.75)
mapPlotHeigth <- max(1, 0.113 * sampleNumb + 1)
```

# Submission information

Please use the information below in communication with Alithea Genomics in case
of further questions and concerns regarding the analysis:<br/>

<div class = "row">
<div class = "col-md-6">
<span style="color: #3A89C9;">**User name: **</span> `r inputArgs['User']`<br/>
<span style="color: #3A89C9;">**PI name: **</span> `r inputArgs['PI']`<br/>
<span style="color: #3A89C9;">**Sequencing run ID: **</span> `r inputArgs['RunID']`<br/>
<span style="color: #3A89C9;">**Sequencing library ID: **</span> `r inputArgs['LibraryID']`<br/>
<span style="color: #3A89C9;">**Sequencing sample ID: **</span> `r inputArgs['SampleID']` 
</div>
<div class = "col-md-6">
This sequencing run was aligned to:<br/>
<span style="color: #3A89C9;">**Specie: **</span> `r inputArgs['Specie']`<br/>
<span style="color: #3A89C9;">**Genome version: **</span> `r inputArgs['Genome']`<br/>
</div>
</div>

# Quality control of the raw sequencing data

## General information
Table below presents technical infomation about current sequencing run. Alithea
Genomics uses modified Illumina paired end sequencing technology: read 1 (R1)
contains information about a sample RNA molucule is coming from and its unique
identified and read 2 contains sequence of RNA molecule. Typical read 1 length 
is 20 - 21 bp, and typical read 2 length is 75bp.

```{r generalInfo, results = 'asis'}
kable(basicStats, caption = 'Information about sequencing')
```

## Per-base sequence quality {.tabset}
The plot below displays quality scores across read length for read 1 and 
read 2. Quality scores above 20 (yellow and green areas) are acceptable for the
further mapping to reference genome. Bad sequence quality is most likely caused
by the sequencing failure. Bases with the sequencing quality below 20 will be 
trimmed futher downstream in the analysis. Trimmed reads which length will be 
below 21bp will be removed from further analysis.

###Read 1
```{r perBaseQC_R1, fig.height = 6, fig.width = 8.5, fig.align = "left"}
plotPerBaseQuality_plotly(perBaseQC_R1, 'Per base quality for R1')
```

###Read 2
```{r perBaseQC_R2, fig.height = 6, fig.width = 8.5, fig.align = "left"}
plotPerBaseQuality_plotly(perBaseQC_R2, 'Per base quality for R2')
```

## Adapter content{.tabset}
The plot below displays adapter contamination across read length for read 1 and
read 2. Flat line indistinguashable from x-axis shows absence of adapter 
contamination. Adapter contamination most commonly arises due to 
overtagmentation. Adapter removal can improve mapping efficiency and will be 
conducted during the analysis below.

###Read 1
```{r adapterQC_R1, fig.height = 6, fig.width = 8.5, fig.align = "left"}
plotAdapterContent_plotly(adapters_R1, 'Adapter contamination in R1')
```

###Read 2
```{r adapterQC_R2, fig.height = 6, fig.width = 8.5, fig.align = "left"}
plotAdapterContent_plotly(adapters_R2, 'Adapter contamination in R2')
```


# Trimming results
During trimming procedure bases of the reads with the quality < 20 are removed.
Bases matching adapter sequences are also removed. Therefore, reads become 
shorter. Reads with length of < 21 are removed from the set. Due to this, 
number of  reads is decreased.

>Important note: read 1 is not trimmed, only read 2 is trimmed.

## Table
Table below presents overview of the trimming statistics, such as number of 
reads with adapters and quality trimmed reads. Row "Number of sequence pairs
removed because at least one read was shorter than the length cutoff" gives a 
precise number and percentage of how many reads were removed from the set
due to either bad quality of bases or adapter contamination.

```{r trimmingTable, results = 'asis'}
trimInf_R2 <- as.data.table(readInTrimmingInfo(inputArgs['trimInfoR2']))
setnames(trimInf_R2, 'Value', 'R2')

kable(trimInf_R2, caption = 'Trimming statistics')
```

## Per-base sequence quality
The plot below displays quality scores across read length for read 2 after 
trimming was completed. Trimming should remove bad quality bases, and blue line
depicting mean quality per base should be higher.

### Read 2
```{r perBaseTrimQC_R2, fig.height = 6, fig.width = 8.5, fig.align = "left"}
plotPerBaseQuality_plotly(perBaseQCtrim_R2, 'Per base quality for R2')
```

## Adapter content 

The plot below displays adapter contamination across read length for read 1 and
read 2 after trimming. Upon successfull trimming, line depicting adapter 
contamination should be barely distinguiashable from x-axis. Read 1 is not show
because trimming on it was not performed.

### Read 2
```{r adapterTrimQC_R2, fig.height = 6, fig.width = 8.5, fig.align = "left"}
plotAdapterContent_plotly(adaptersTrim_R2, 'Adapter contamination in R1')
```

# Demultiplexing {.tabset}
Table below presents an overview of the results of the demultiplexing 
procedure. Usually about 5% of the reads are lost at this step due to various
reasons such as poor barcode base quality.

```{r demultiplexStats, results = "asis"}
kable(demultiplexStats[[1]], caption = 'Overview of demultiplexing')
```

## Bar plot

The chart below depicts a distribution of the percentage of total reads 
allocated per sample. A two fold variation is expected and normal.

```{r demultiplexStatsPlot, fig.height = mapPlotHeigth, fig.width = 8.5, fig.align = "left"}
plotBarChart_plotly(demultiplexStats[[2]], 'Percent', '% of reads per sample',
                    'Demultiplexing results')
```

## Plate view

The chart below depicts a distribution of the percentage of total reads 
allocated per sample as loaded on the plate. It can help you to determine if 
sequencing bias can be explained based on plate position.

```{r demultiplexPlatePlot, fig.height = 6, fig.width = 8.5, fig.align = "left"}
plotDemultiplexPlate_plotly(demultiplexStats[[2]], 
                            '% of reads per sample, plate view')
```

# Mapping {.tabset}

Mapping of the data was performed using STAR v.2.7.3a and number of uniquely
mapped reads, mapped to too many loci reads, not mapped reads, etc was 
assessed.

## Barplot - raw values
This bar plot shows mapping statistics across samples as total number of reads.
Hover over the bars to see the actual numbers.

```{r mapStatsPlot, fig.height = mapStatsHeigth, fig.width = 8.5, fig.align = "left"}
plotMappingStats_plotly(mapStatTab, 'Overview of mapping statistics')
```

## Barplot - percentages
This bar plot shows mapping statistics across samples in percentages.
Hover over the bars to see the actual numbers. Typical percentage of uniquely
mapped reads is around 75%.

```{r mapStatsPlotPerc, fig.height = mapStatsHeigth, fig.width = 8.5, fig.align = "left"}
plotMappingStats_plotly(convertMapStatsToPerc(mapStatTab), 
                        'Overview of mapping statistics (in %)')
```

## Table 
A table representation of the mapping statistics. It is also avaible as a
separate file.

```{r mapStatsTab, results = 'asis'}
kable(mapStatTab, caption = 'Mapping statistics') %>%
      kable_styling(bootstrap_options = c("striped", "hover", "condensed",
                                          "responsive")) %>%
  scroll_box(width = "100%", height = "500px")
```

# Exonic reads {.tabset}

Number of exonic reads were assesed as sum of all reads assigned to genes.

## Number of reads

The bar chart below presents raw number of reads per sample assigned to exons.

```{r exonicReads, fig.height = mapPlotHeigth, fig.width = 8.5, fig.align = "left"}
plotBarChart_plotly(exonicReads, mode = 'Reads', 
                    'Number of exonic reads per sample',
                    'Number of exonic reads per sample')
```

## % from uniquely mapped

The bar chart below presents percentage of reads assigned to exons from the 
uniquely mapped ones per sample.

```{r exonicReadsPerc, fig.height = mapPlotHeigth, fig.width = 8.5, fig.align = "left"}
plotBarChart_plotly(exonicReads, mode = 'Percent',  
                    '% of exonic reads per sample',
                    '% of exonic reads per sample')
```

## Table 

A table representation of the number and percentage of the exonic reads per 
sample. It is also avaible in the separate file.

```{r exonicReadsTab, results = 'asis'}
colnames(exonicReads) <- c('Sample', 'Number of reads',
                           '% from uniquely mapped')
kable(exonicReads, caption = 'Exonic reads') %>%
      kable_styling(bootstrap_options = c("striped", "hover", "condensed",
                                          "responsive")) %>%
  scroll_box(width = "100%", height = "500px")
```

# Number of expressed genes {.tabset}

Number of expressed genes was calculated as number of genes with more than 1 
(or 10) reads assigned per gene.

## > 1 read per gene
Number of genes with > 1 read assigned per gene
```{r numbExprGenes1, fig.height = mapPlotHeigth, fig.width = 8.5, fig.align = "left"}
plotBarChart_plotly(numbExprGenes1, mode = 'NumbGenes', 
                    'Number of genes with > 1 reads', 
                    'Number of genes')
```

## > 10 reads per gene
Number of genes with > 10 reads assigned per gene
```{r numbExprGenes10, fig.height = mapPlotHeigth, fig.width = 8.5, fig.align = "left"}
plotBarChart_plotly(numbExprGenes10, mode = 'NumbGenes',  
                    'Number of genes with > 10 reads',
                    'Number of genes')
```

## Table
Table representation of the number of expressed genes (> 1 read assigned per 
gene).
```{r NumbGenesTab, results = 'asis'}
colnames(numbExprGenes1) <- c('Sample', 'Number of genes')
kable(numbExprGenes1, caption = 'Number of genes with > 1 read') %>%
      kable_styling(bootstrap_options = c("striped", "hover", "condensed",
                                          "responsive")) %>%
  scroll_box(width = "100%", height = "500px")
```

# PCA {.tabset}
Principle Component Analysis (PCA) was performed on raw (integer) count table
and on normalized for sequencing depth count table. Comparison of the two plots
below will help you to determine the gravity of the sequencing depth's effect 
on you data. Percentages in the axis names signify percentage of variation 
expained by a principle component.

## raw counts 
PCA based on raw (integer) counts
```{r pcaRaw, fig.height = 6, fig.width = 8.5, fig.align = "left"}
plotPCA_plotly(countsRawPCA, 'PCA based on raw counts')
```

## normalized data
PCA based on normalized for sequencing depth data
```{r PcaNorm, fig.height = 6, fig.width = 8.5, fig.align = "left"}
plotPCA_plotly(countsNormPCA, 'PCA based on normalized counts')
```
