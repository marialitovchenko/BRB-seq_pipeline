---
title: "Data analysis report"
author: "by Alithea Genomics"
date: "6/17/2020"
fontsize: 20pt 
output: 
  html_document:
    toc: true # table of content true
    toc_depth: 3  # upto three depths of headings (specified by #, ## and ###)
    number_sections: true # number sections at each table header
params:
  args: inputArgs
---

```{r markdown_setup, include = FALSE}
knitr::opts_chunk$set(echo = F)
inputArgs <- c('test_input/fastQC/nxid12916/BRBseq_v3_plate_1_S25/BRBseq_v3_plate_1_S25_R1_001_fastqc/fastqc_data.txt',
               'test_input/fastQC/nxid12916/BRBseq_v3_plate_1_S25/BRBseq_v3_plate_1_S25_R1_001_fastqc/fastqc_data.txt', 
               'test_input/BRBseq_v3_plate_1_S25_R2_001.fastq.gz_trimming_report.txt',
               'test_input/BRBseq_v3_plate_1_S25_val_1_fastqc/fastqc_data.txt',
               'test_input/mapStatsTab.csv')
names(inputArgs) <- c('fastqcR1', 'fastqcR2', 'trimInfoR2', 'fastqcTrimR2', 'mapStats')
```

```{r setup_and_functions, include = FALSE}
library(data.table)
library(DT)
library(ggrepel)
library(ggplot2)
library(ggpubr)
library(ggsignif)
library(plotly)
library(plyr)

# plotting theme
mashaGgplot2Theme <- list(
  theme_classic(base_size = 12) +
    theme(axis.line.x = element_line(colour = 'black', size = 0.5,
                                     linetype = 'solid'),
          axis.text.x = element_text(colour = 'black', size = 12),
          axis.line.y = element_line(colour = 'black', size = 0.5,
                                     linetype ='solid'),
          axis.text.y = element_text(colour = 'black', size = 12),
          strip.background = element_blank())
)

# colors
colorCode <- c("mapped to mult. loci" = '#FFBABA', 
               "NOT mapped - mismatches" = '#C48484', 
               'NOT mapped - too short' = '#991D1D',
               'NOT mapped - other' = '#730202', 
               'mapped to too many loci' = 'black',
               "uniquely mapped" = "#0C8954")

#' readFastQCsection
#' Reads a part of the fastqc report TXT file and converts it to data table
#' @param filePath path to the TXT file
#' @param sectionName name of the section you want to be read, i.e. 
#'                    '>>Per base sequence quality' or '>>Adapter Content'
readFastQCsection <- function(filePath, sectionName) {
  # connection to the file
  connect <- file(filePath, open = "r")
  # read ALL lines of the file, luckily it's not many
  allLines <- readLines(connect)
  # indicates if result vector containing line corresponding to section of 
  # interest needs to be recorded into result variable
  startFilling <- F
  result <- c()
  for (oneLine in allLines){
    if (grepl(sectionName, oneLine)) {
      startFilling <- T
      next
    } 
    if (startFilling & grepl('>>END_MODULE', oneLine)) {
      startFilling <- F
    }
    if (startFilling) {
      result <- c(result, oneLine)
    }
  }
  close(connect)
  
  # split by tab
  result <- sapply(result, function(x) strsplit(x, '\t'))
  names(result) <- NULL
  # convert to data table
  result <- do.call(rbind, result)
  colnames(result) <- result[1, ]
  colnames(result)[1] <- gsub("^#", "", colnames(result)[1]) 
  result <- result[-1, ]
  result <- as.data.table(result)
  result <- as.data.table(apply(result, 2, as.numeric))

  result
}

#' plotPerBaseQuality_ggplot2
#' Plots per base quality of the read, just like seen in FASTQC report 
#' with ggplot2
#' @param dtToPlot data table to plot, result of readFastQCsection
#' @param plotTitle title of the plot
#' @return ggplot
plotPerBaseQuality_ggplot2 <- function(dtToPlot, plotTitle = '') {
  redArea <- data.frame(x1 = 0, x2 = max(dtToPlot$Base), y1 = 0, y2 = 20)
  yelArea <- data.frame(x1 = 0, x2 = max(dtToPlot$Base), y1 = 20, y2 = 28)
  greenArea <- data.frame(x1 = 0, x2 = max(dtToPlot$Base), y1 = 28, y2 = 40)
  result <- ggplot(dtToPlot, aes(x = Base, y = Median)) + 
    geom_point(shape = 95) + 
    geom_errorbar(aes(ymin = `10th Percentile`, 
                      ymax = `90th Percentile`), width=.2,
                   position=position_dodge(.9)) +
    geom_line(aes(x = Base, y = Mean), color = 'blue') + 
    geom_rect(data = redArea, inherit.aes = F, fill = "red",  alpha = 0.2,
              mapping = aes(xmin = x1, xmax = x2, ymin = y1, ymax = y2)) +
    geom_rect(data = yelArea, inherit.aes = F, fill = "yellow",  alpha = 0.2,
              mapping = aes(xmin = x1, xmax = x2, ymin = y1, ymax = y2)) +
    geom_rect(data = greenArea, inherit.aes = F, fill = "green",  alpha = 0.2,
              mapping = aes(xmin = x1, xmax = x2, ymin = y1, ymax = y2)) +
    scale_x_continuous(breaks = seq(0, max(dtToPlot$Base), 1)) + 
    scale_y_continuous(breaks = seq(0, 40, 1)) +
    xlab('Quality score') + ylab('Position in the read, bp') +
    ggtitle(plotTitle) + mashaGgplot2Theme
  result
}

#' plotPerBaseQuality_ggplot2
#' Plots per base quality of the read, just like seen in FASTQC report 
#' with plotly
#' @param dtToPlot data table to plot, result of readFastQCsection
#' @param plotTitle title of the plot
#' @return plotly
plotPerBaseQuality_plotly <- function(dtToPlot, plotTitle = '') {
  fig <- plot_ly(data = dtToPlot) %>% 
                add_trace(x = ~Base, y = ~Median, type = "scatter", 
                          mode = "markers", 
                marker = list(symbol = 'line-ew-open', color = 'black'),
                error_y = ~list(symmetric = F, color = 'black',
                                arrayminus = Median - `10th Percentile`,
                                array = `90th Percentile` - Median)) %>% 
                add_trace(x = ~Base, y = ~Mean, type="scatter", mode = "lines",
                line = list(color = 'blue'))
  fig <- fig %>%
         layout(fig, title = plotTitle, showlegend = F,
                xaxis = list(title = 'Position in the read, bp', dtick = 1,
                             range = c(0, max(dtToPlot$Base)), showgrid = F),
                yaxis = list(title = 'Sequencing quality', dtick = 1, 
                             range = c(0, 
                                       max(c(40, dtToPlot$`90th Percentile`))),
                             showgrid = F),
                shapes = list(list(type = "rect", fillcolor = "red",
                                   line = list(color = "red"), opacity = 0.3,
                                   x0 = 0, x1 = max(dtToPlot$Base), xref = "x",
                                   y0 = 0, y1 = 20, yref = "y"),
                              list(type = "rect", fillcolor = "yellow", 
                                   line = list(color = "yellow"),
                                   opacity = 0.2, x0 = 0, x1 = max(dtToPlot$Base), 
                                   xref = "x", y0 = 20, y1 = 28, yref = "y"),
                              list(type = "rect", fillcolor = "green", 
                                   line = list(color = "green"),
                                   opacity = 0.2, x0 = 0, x1 = max(dtToPlot$Base),
                                   xref = "x", y0 = 28, y1 = 40, yref = "y")),
                font = list(family = "Helvetica", size = 12))
  fig
}

#' plotAdapterContent_ggplot2
#' Plots adapter content in the read, just like seen in FASTQC report with use
#' of ggplot2 
#' @param dtToPlot data table to plot, result of readFastQCsection
#' @param plotTitle title of the plot
#' @return ggplot2
plotAdapterContent_ggplot2 <- function(dtToPlot, plotTitle = '') {
  dtToPlot <- melt(copy(dtToPlot), 'Position')
  result <- ggplot(dtToPlot, aes(x = Position, y = value, color = variable)) +
    geom_line() +
    scale_color_manual(values = c('red', 'blue', 'green', 'black', 'magenta'))+
    scale_x_continuous(breaks = seq(0, max(adapters_R1$Position), 1)) + 
    scale_y_continuous(limits = c(0, 100), breaks = seq(0, 100, 10)) +
    xlab('Position in read') + ylab('% Adapter') +
    theme(legend.position = "topright") + labs(color = "Adapter") +
    ggtitle(plotTitle) + mashaGgplot2Theme
  result
}

#' plotAdapterContent_plotly
#' Plots adapter content in the read, just like seen in FASTQC report with use
#' of plotly
#' @param dtToPlot data table to plot, result of readFastQCsection
#' @param plotTitle title of the plot
#' @return plotly
plotAdapterContent_plotly <- function(dtToPlot, plotTitle = '') {
  dtToPlot <- melt(copy(dtToPlot), 'Position')
  fig <- plot_ly(data = dtToPlot) %>% 
    add_trace(x = ~Position, y = ~value, type = "scatter", 
              color = ~variable, mode = "lines")
  fig <- fig %>%
    layout(fig, title = plotTitle, 
           xaxis = list(title = 'Position in read, bp', 
                        dtick = 1, range = c(0, max(dtToPlot$Position)),
                        showgrid = F),
           yaxis = list(title = 'Adapter %', dtick = 10,
                        range = c(0, 100), showgrid = F),
           font = list(family = "Helvetica", size = 12))
  fig
}

#' readInTrimmingInfo
#' Reads in and extracts needed information from trimming report produced by
#' TrimGalore
#' @param filePath path to the trimming report
#' @return data table with 2 columns
readInTrimmingInfo <- function(filePath) {
  # lines of interest
  LOI <- c('Adapter sequence', 'Total reads processed', 
           'Reads with adapters', 'Reads written',
           'Total basepairs processed', 'Quality-trimmed',
           'Total written',
           'Number of sequence pairs removed because')
  LOI <- paste(LOI, collapse = "|")

  # connection to the file
  connect <- file(filePath, open = "r")
  # read ALL lines of the file, luckily it's not many
  allLines <- readLines(connect)
  # indicates if result vector containing line corresponding to section of 
  # interest needs to be recorded into result variable
  startFilling <- F
  result <- c()
  for (oneLine in allLines){
    if (grepl(LOI, oneLine)) {
      result <- c(result, oneLine)
    }
  }
  close(connect)
  
  # convert to table
  result <- sapply(result, function(x) strsplit(x, ':'))
  names(result) <- NULL
  result <- do.call(rbind, result)
  result[, 2] <- gsub('^ +', '', result[, 2])
  result <- as.data.frame(result)
  colnames(result) <- c('Property', 'Value')
  result
}
```

```{r readInput, include = FALSE}
# number of raw reads in R1 and R2
basicStats_R1 <- readFastQCsection(inputArgs['fastqcR1'], '>>Basic Statistics')
basicStats_R2 <- readFastQCsection(inputArgs['fastqcR2'], '>>Basic Statistics')
basicStats <- data.frame(R1 = c(basicStats_R1$Value[4],basicStats_R1$Value[6],
                                basicStats_R1$Value[7]),
                         R2 = c(basicStats_R2$Value[4],basicStats_R2$Value[6],
                                basicStats_R2$Value[7]))
rownames(basicStats) <- c('Number of reads', 'Read length', 'GC percentage')

# per base sequencing quality for R1
perBaseQC_R1 <- readFastQCsection(inputArgs['fastqcR1'], 
                                  '>>Per base sequence quality')
# per base sequencing quality for R2
perBaseQC_R2 <- readFastQCsection(inputArgs['fastqcR2'], 
                                  '>>Per base sequence quality')

# adapter contamination for R1
adapters_R1 <- readFastQCsection(inputArgs['fastqcR1'], '>>Adapter Content')
# adapter contamination for R2
adapters_R2 <- readFastQCsection(inputArgs['fastqcR2'], '>>Adapter Content')

# trimming report for R2
trimInf_R2 <- as.data.table(readInTrimmingInfo(inputArgs['trimInfoR2']))
# per base sequencing quality for R2 after trimming
perBaseQCtrim_R2 <- readFastQCsection(inputArgs['fastqcTrimR2'], 
                                     '>>Per base sequence quality')
# adapter contamination for R2 after trimming
adaptersTrim_R2 <- readFastQCsection(inputArgs['fastqcTrimR2'], 
                                     '>>Adapter Content')

```

# Quality control of the raw sequencing data
## General information

```{r generalInfo, results = 'asis'}
library(knitr)
kable(basicStats, caption = 'Information about sequencing')
```

## Per-base sequence quality {.tabset}
The plot below displays quality scores across read length for read 1 (barcodes)
and read 2 (actual RNA).

Bad sequence quality
most likely caused by the sequencing machine failure
or tagmentation

###R1
```{r perBaseQC_R1, fig.height = 6, fig.width = 8, fig.align = "left"}
plotPerBaseQuality_plotly(perBaseQC_R1, 'Per base quality for R1')
```

###R2
```{r perBaseQC_R2, fig.height = 6, fig.width = 8, fig.align = "left"}
plotPerBaseQuality_plotly(perBaseQC_R2, 'Per base quality for R2')
```

## Adapter content{.tabset}

Adapter contamination

###R1
```{r adapterQC_R1, fig.height = 6, fig.width = 8, fig.align = "left"}
plotAdapterContent_plotly(adapters_R1, 'Adapter contamination in R1')
```

###R2
```{r adapterQC_R2, fig.height = 6, fig.width = 8, fig.align = "left"}
plotAdapterContent_plotly(adapters_R2, 'Adapter contamination in R2')
```


# Trimming results

>Important note: R1 is not trimmed. 

## Table
```{r trimmingTable, results = 'asis'}
trimInf_R2 <- as.data.table(readInTrimmingInfo(inputArgs['trimInfoR2']))
setnames(trimInf_R2, 'Value', 'R2')

library(knitr)
kable(trimInf_R2, caption = 'Trimming statistics')
```

## Per-base sequence quality
After trimming

### R2
```{r perBaseTrimQC_R2, fig.height = 6, fig.width = 8, fig.align = "left"}
plotPerBaseQuality_plotly(perBaseQCtrim_R2, 'Per base quality for R2')
```

## Adapter content 

### R2
```{r adapterTrimQC_R2, fig.height = 6, fig.width = 8, fig.align = "left"}
plotAdapterContent_plotly(adaptersTrim_R2, 'Adapter contamination in R1')
```
