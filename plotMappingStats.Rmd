---
title: "Untitled"
author: "Maria Litovchenko"
date: "16/04/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r Libraries}
library(data.table)
```

```{r Functions}
#' extractCountsColumn
#' @param filePath path to the counts file
#' @param sampleName string, sample name
#' @return data.table with column name = sample name
#' @note I don't need to know which sample I'm considering as the only sample
#'       with non-zero counts will be the one which was submitted to countDGE
#'       from BRB-seq tools. However, if all samples failed and none of the 
#'       reads were assigned to the genes, I have a problem. So still request a
#'       sample name as an input.
extractCountsColumn <- function(filePath, sampleName) {
  oneSampleCounts <- fread(filePath, header = T, stringsAsFactors = F)
  maxCounts <- as.integer(apply(oneSampleCounts, 2, max))
  if (max(maxCounts, na.rm = T) != 0) {
    # here it's != 0 and not compared to maximum, in order to catch if only
    # one sample has assigned counts
    sampleIndex <- which(maxCounts != 0)
    if (length(sampleIndex) == 1) {
        guessName <- colnames(oneSampleCounts)[sampleIndex]
        if (guessName == sampleName) {
          result <- oneSampleCounts[, sampleIndex, with = F]
        } else {
          msg <- paste0("Given sample name (", sampleName, ") doesn't",
                        " correspond to the sample with the counts in ",
                        "the table (", colnames(oneSampleCounts)[sampleIndex],
                        "). Assigning given sample name (", sampleName, ")",
                        " and taking counts from corresponding column.")
          warning(msg)
          result <- oneSampleCounts[, sampleName]
        }
    } else {
      msg <- paste0("Multiple samples have counts in this table, although",
                    sampleName, "is assigned as main sample. ",
                    "Assigning given sample name (", sampleName, ")",
                    " and taking counts from corresponding column.")
      warning(msg)
      result <- oneSampleCounts[, sampleName]
    }
  } else {
    msg <- paste0("No reads falling within the genes was found for any",
                  "sample.")
    warning(msg)
    result <- oneSampleCounts[, sampleName]
  }
  result
}

#' mergeCountsInto1Tab
#' 
#' @param
mergeCountsInto1Tab <- function(countsPaths) {
  # extract names of the samples from the paths
  sampleNames <- sapply(countsPaths, function(x) gsub('[.].*', '', x))
  countCols <- lapply(1:length(sampleNames), 
                      function(x) extractCountsColumn(countsPaths[[x]],
                                                      sampleNames[x]))
}
```

```{r read inputs}
# read-in info table containing info about runs, libraries, genomes, counts
infoTab <- fread('rInputTab.txt', header = F, stringsAsFactors = F)
infoNames <- c('Run', 'Library', 'Sample', 'Specie', 'Genome', 
               'Trimmed_Index_Fq', 'Trimmed_Data_Fq', 'Demultiplex_Fq',
               'Mapped', 'Map_stats', 'Counts_UMI', 'Counts_Reads')
setnames(infoTab, colnames(infoTab), infoNames)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r cars}
summary(cars)
```

## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
